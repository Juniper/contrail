// Code generated by MockGen. DO NOT EDIT.
// Source: pkg/types/ipam/address_manager.go

// Package ipammock is a generated GoMock package.
package ipammock

import (
	context "context"
	ipam "github.com/Juniper/contrail/pkg/types/ipam"
	gomock "github.com/golang/mock/gomock"
	reflect "reflect"
)

// MockErrSubnetExhausted is a mock of ErrSubnetExhausted interface
type MockErrSubnetExhausted struct {
	ctrl     *gomock.Controller
	recorder *MockErrSubnetExhaustedMockRecorder
}

// MockErrSubnetExhaustedMockRecorder is the mock recorder for MockErrSubnetExhausted
type MockErrSubnetExhaustedMockRecorder struct {
	mock *MockErrSubnetExhausted
}

// NewMockErrSubnetExhausted creates a new mock instance
func NewMockErrSubnetExhausted(ctrl *gomock.Controller) *MockErrSubnetExhausted {
	mock := &MockErrSubnetExhausted{ctrl: ctrl}
	mock.recorder = &MockErrSubnetExhaustedMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockErrSubnetExhausted) EXPECT() *MockErrSubnetExhaustedMockRecorder {
	return m.recorder
}

// SubnetExhausted mocks base method
func (m *MockErrSubnetExhausted) SubnetExhausted() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "SubnetExhausted")
}

// SubnetExhausted indicates an expected call of SubnetExhausted
func (mr *MockErrSubnetExhaustedMockRecorder) SubnetExhausted() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SubnetExhausted", reflect.TypeOf((*MockErrSubnetExhausted)(nil).SubnetExhausted))
}

// MockAddressManager is a mock of AddressManager interface
type MockAddressManager struct {
	ctrl     *gomock.Controller
	recorder *MockAddressManagerMockRecorder
}

// MockAddressManagerMockRecorder is the mock recorder for MockAddressManager
type MockAddressManagerMockRecorder struct {
	mock *MockAddressManager
}

// NewMockAddressManager creates a new mock instance
func NewMockAddressManager(ctrl *gomock.Controller) *MockAddressManager {
	mock := &MockAddressManager{ctrl: ctrl}
	mock.recorder = &MockAddressManagerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockAddressManager) EXPECT() *MockAddressManagerMockRecorder {
	return m.recorder
}

// AllocateIP mocks base method
func (m *MockAddressManager) AllocateIP(arg0 context.Context, arg1 *ipam.AllocateIPRequest) (string, string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "AllocateIP", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(string)
	ret2, _ := ret[2].(error)
	return ret0, ret1, ret2
}

// AllocateIP indicates an expected call of AllocateIP
func (mr *MockAddressManagerMockRecorder) AllocateIP(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AllocateIP", reflect.TypeOf((*MockAddressManager)(nil).AllocateIP), arg0, arg1)
}

// DeallocateIP mocks base method
func (m *MockAddressManager) DeallocateIP(arg0 context.Context, arg1 *ipam.DeallocateIPRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeallocateIP", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeallocateIP indicates an expected call of DeallocateIP
func (mr *MockAddressManagerMockRecorder) DeallocateIP(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeallocateIP", reflect.TypeOf((*MockAddressManager)(nil).DeallocateIP), arg0, arg1)
}

// IsIPAllocated mocks base method
func (m *MockAddressManager) IsIPAllocated(arg0 context.Context, arg1 *ipam.IsIPAllocatedRequest) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsIPAllocated", arg0, arg1)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// IsIPAllocated indicates an expected call of IsIPAllocated
func (mr *MockAddressManagerMockRecorder) IsIPAllocated(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsIPAllocated", reflect.TypeOf((*MockAddressManager)(nil).IsIPAllocated), arg0, arg1)
}

// CreateIpamSubnet mocks base method
func (m *MockAddressManager) CreateIpamSubnet(arg0 context.Context, arg1 *ipam.CreateIpamSubnetRequest) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CreateIpamSubnet", arg0, arg1)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CreateIpamSubnet indicates an expected call of CreateIpamSubnet
func (mr *MockAddressManagerMockRecorder) CreateIpamSubnet(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateIpamSubnet", reflect.TypeOf((*MockAddressManager)(nil).CreateIpamSubnet), arg0, arg1)
}

// CheckIfIpamSubnetExists mocks base method
func (m *MockAddressManager) CheckIfIpamSubnetExists(ctx context.Context, subnetUUID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CheckIfIpamSubnetExists", ctx, subnetUUID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CheckIfIpamSubnetExists indicates an expected call of CheckIfIpamSubnetExists
func (mr *MockAddressManagerMockRecorder) CheckIfIpamSubnetExists(ctx, subnetUUID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CheckIfIpamSubnetExists", reflect.TypeOf((*MockAddressManager)(nil).CheckIfIpamSubnetExists), ctx, subnetUUID)
}

// DeleteIpamSubnet mocks base method
func (m *MockAddressManager) DeleteIpamSubnet(arg0 context.Context, arg1 *ipam.DeleteIpamSubnetRequest) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteIpamSubnet", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// DeleteIpamSubnet indicates an expected call of DeleteIpamSubnet
func (mr *MockAddressManagerMockRecorder) DeleteIpamSubnet(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteIpamSubnet", reflect.TypeOf((*MockAddressManager)(nil).DeleteIpamSubnet), arg0, arg1)
}
