diff -Naur -x '*.pyc' site-packages_orig/cfgm_common/vnc_cassandra.py site-packages/cfgm_common/vnc_cassandra.py
--- site-packages_orig/cfgm_common/vnc_cassandra.py	2018-07-12 04:35:21.000000000 +0200
+++ site-packages/cfgm_common/vnc_cassandra.py	2018-08-23 12:45:29.899671543 +0200
@@ -722,7 +722,7 @@
             if prop_field in obj_class.prop_list_fields:
                 # store list elements in list order
                 # iterate on wrapped element or directly or prop field
-                if obj_class.prop_list_field_has_wrappers[prop_field]:
+                if obj_class.prop_list_field_has_wrappers[prop_field] and len(field.keys()) > 0:
                     wrapper_field = field.keys()[0]
                     list_coll = field[wrapper_field]
                 else:
@@ -733,7 +733,7 @@
                         bch, obj_id, prop_field, list_coll[i], str(i))
             elif prop_field in obj_class.prop_map_fields:
                 # iterate on wrapped element or directly or prop field
-                if obj_class.prop_map_field_has_wrappers[prop_field]:
+                if obj_class.prop_map_field_has_wrappers[prop_field] and len(field.keys()) > 0:
                     wrapper_field = field.keys()[0]
                     map_coll = field[wrapper_field]
                 else:
diff -Naur -x '*.pyc' site-packages_orig/vnc_cfg_api_server/vnc_cfg_api_server.py site-packages/vnc_cfg_api_server/vnc_cfg_api_server.py
--- site-packages_orig/vnc_cfg_api_server/vnc_cfg_api_server.py	2018-07-12 04:35:21.000000000 +0200
+++ site-packages/vnc_cfg_api_server/vnc_cfg_api_server.py	2018-08-24 09:09:41.477536641 +0200
@@ -700,38 +700,38 @@
         obj_dict = get_request().json[resource_type]
 
         # check visibility
-        user_visible = (obj_dict.get('id_perms') or {}).get('user_visible', True)
-        if not user_visible and not self.is_admin_request():
-            result = 'This object is not visible by users'
-            self.config_object_error(None, None, obj_type, 'http_post', result)
-            raise cfgm_common.exceptions.HttpError(400, result)
+      #  user_visible = (obj_dict.get('id_perms') or {}).get('user_visible', True)
+       # if not user_visible and not self.is_admin_request():
+        #    result = 'This object is not visible by users'
+         #   self.config_object_error(None, None, obj_type, 'http_post', result)
+          #  raise cfgm_common.exceptions.HttpError(400, result)
 
-        self._post_validate(obj_type, obj_dict=obj_dict)
+        #self._post_validate(obj_type, obj_dict=obj_dict)
         fq_name = obj_dict['fq_name']
-        try:
-            self._extension_mgrs['resourceApi'].map_method(
-                 'pre_%s_create' %(obj_type), obj_dict)
-        except RuntimeError:
-            # lack of registered extension leads to RuntimeError
-            pass
-        except Exception as e:
-            err_msg = 'In pre_%s_create an extension had error for %s' \
-                      %(obj_type, obj_dict)
-            err_msg += cfgm_common.utils.detailed_traceback()
-            self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
+        #try:
+         #   self._extension_mgrs['resourceApi'].map_method(
+         #        'pre_%s_create' %(obj_type), obj_dict)
+        #except RuntimeError:
+        #    # lack of registered extension leads to RuntimeError
+        #    pass
+        #except Exception as e:
+        #    err_msg = 'In pre_%s_create an extension had error for %s' \
+        #              %(obj_type, obj_dict)
+        #    err_msg += cfgm_common.utils.detailed_traceback()
+        #    self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
 
         # properties validator
-        ok, result = self._validate_props_in_request(r_class,
-                     obj_dict, operation='CREATE')
-        if not ok:
-            result = 'Bad property in create: ' + result
-            raise cfgm_common.exceptions.HttpError(400, result)
+        #ok, result = self._validate_props_in_request(r_class,
+        #             obj_dict, operation='CREATE')
+        #f not ok:
+        #    result = 'Bad property in create: ' + result
+        #    raise cfgm_common.exceptions.HttpError(400, result)
 
         # references validator
-        ok, result = self._validate_refs_in_request(r_class, obj_dict)
-        if not ok:
-            result = 'Bad reference in create: ' + result
-            raise cfgm_common.exceptions.HttpError(400, result)
+        #ok, result = self._validate_refs_in_request(r_class, obj_dict)
+        #if not ok:
+        #    result = 'Bad reference in create: ' + result
+        #    raise cfgm_common.exceptions.HttpError(400, result)
 
         # Can abort resource creation and retrun 202 status code
         get_context().set_state('PENDING_DBE_CREATE')
@@ -739,7 +739,7 @@
         if not ok:
             code, msg = result
             raise cfgm_common.exceptions.HttpError(code, msg)
-        if ok and isinstance(result, tuple) and result[0] == 202:
+        if False and ok and isinstance(result, tuple) and result[0] == 202:
             # Creation accepted but not applied, pending delete return 202 HTTP
             # OK code to aware clients
             pending_obj_dict = result[1]
@@ -758,10 +758,10 @@
 
         get_context().set_state('PRE_DBE_ALLOC')
         # type-specific hook
-        ok, result = r_class.pre_dbe_alloc(obj_dict)
-        if not ok:
-            code, msg = result
-            raise cfgm_common.exceptions.HttpError(code, msg)
+        #ok, result = r_class.pre_dbe_alloc(obj_dict)
+        #if not ok:
+        #    code, msg = result
+        #    raise cfgm_common.exceptions.HttpError(code, msg)
 
         # common handling for all resource create
         (ok, result) = self._post_common(obj_type, obj_dict)
@@ -778,40 +778,40 @@
         db_conn = self._db_conn
 
         # if client gave parent_type of config-root, ignore and remove
-        if 'parent_type' in obj_dict and obj_dict['parent_type'] == 'config-root':
-            del obj_dict['parent_type']
-
-        parent_class = None
-        if 'parent_type' in obj_dict:
-            # non config-root child, verify parent exists
-            parent_res_type, parent_class = self._validate_resource_type(
-                 obj_dict['parent_type'])
-            parent_obj_type = parent_class.object_type
-            parent_res_type = parent_class.resource_type
-            parent_fq_name = obj_dict['fq_name'][:-1]
-            try:
-                parent_uuid = self._db_conn.fq_name_to_uuid(parent_obj_type,
-                                                            parent_fq_name)
-                (ok, status) = self._permissions.check_perms_write(
-                    get_request(), parent_uuid)
-                if not ok:
-                    (code, err_msg) = status
-                    raise cfgm_common.exceptions.HttpError(code, err_msg)
-                self._permissions.set_user_role(get_request(), obj_dict)
-                obj_dict['parent_uuid'] = parent_uuid
-            except NoIdError:
-                err_msg = 'Parent %s type %s does not exist' % (
-                    pformat(parent_fq_name), parent_res_type)
-                fq_name_str = ':'.join(parent_fq_name)
-                self.config_object_error(None, fq_name_str, obj_type, 'http_post', err_msg)
-                raise cfgm_common.exceptions.HttpError(400, err_msg)
+        #if 'parent_type' in obj_dict and obj_dict['parent_type'] == 'config-root':
+        #    del obj_dict['parent_type']
+#
+        #parent_class = None
+        #if 'parent_type' in obj_dict:
+        #    # non config-root child, verify parent exists
+        #    parent_res_type, parent_class = self._validate_resource_type(
+        #         obj_dict['parent_type'])
+        #    parent_obj_type = parent_class.object_type
+        #    parent_res_type = parent_class.resource_type
+        #    parent_fq_name = obj_dict['fq_name'][:-1]
+        #    try:
+        #        parent_uuid = self._db_conn.fq_name_to_uuid(parent_obj_type,
+        #                                                    parent_fq_name)
+        #        (ok, status) = self._permissions.check_perms_write(
+        #            get_request(), parent_uuid)
+        #        if not ok:
+        #            (code, err_msg) = status
+        #            raise cfgm_common.exceptions.HttpError(code, err_msg)
+        #        self._permissions.set_user_role(get_request(), obj_dict)
+        #        obj_dict['parent_uuid'] = parent_uuid
+        #    except NoIdError:
+        #        err_msg = 'Parent %s type %s does not exist' % (
+        #            pformat(parent_fq_name), parent_res_type)
+        #        fq_name_str = ':'.join(parent_fq_name)
+        #        self.config_object_error(None, fq_name_str, obj_type, 'http_post', err_msg)
+        #        raise cfgm_common.exceptions.HttpError(400, err_msg)
 
         # Validate perms on references
-        try:
-            self._validate_perms_in_request(r_class, obj_type, obj_dict)
-        except NoIdError:
-            raise cfgm_common.exceptions.HttpError(
-                400, 'Unknown reference in resource create %s.' %(obj_dict))
+        #try:
+        #    self._validate_perms_in_request(r_class, obj_type, obj_dict)
+        #except NoIdError:
+        #    raise cfgm_common.exceptions.HttpError(
+        #        400, 'Unknown reference in resource create %s.' %(obj_dict))
 
         # State modification starts from here. Ensure that cleanup is done for all state changes
         cleanup_on_failure = []
@@ -832,64 +832,64 @@
 
             get_context().set_state('PRE_DBE_CREATE')
             # type-specific hook
-            (ok, result) = r_class.pre_dbe_create(
-                    tenant_name, obj_dict, db_conn)
-            if not ok:
-                return (ok, result)
+            #(ok, result) = r_class.pre_dbe_create(
+            #        tenant_name, obj_dict, db_conn)
+            #if not ok:
+            #    return (ok, result)
 
             callable = getattr(r_class, 'http_post_collection_fail', None)
             if callable:
                 cleanup_on_failure.append((callable, [tenant_name, obj_dict, db_conn]))
 
-            ok, quota_limit, proj_uuid = r_class.get_quota_for_resource(obj_type,
-                                                                        obj_dict, db_conn)
-            if not ok:
-                return ok, quota_limit
+            #ok, quota_limit, proj_uuid = r_class.get_quota_for_resource(obj_type,
+            #                                                            obj_dict, db_conn)
+            #if not ok:
+            #    return ok, quota_limit
 
             get_context().set_state('DBE_CREATE')
 
-            if quota_limit >= 0:
-                path = self._path_prefix + proj_uuid + "/" + obj_type
-                if not self.quota_counter.get(path):
-                    # Init quota counter
-                    path_prefix = self._path_prefix + proj_uuid
-                    try:
-                        QuotaHelper._zk_quota_counter_init(
-                                   path_prefix, {obj_type: quota_limit}, proj_uuid,
-                                   self._db_conn, self.quota_counter)
-                    except NoIdError:
-                        msg = "Error in initializing quota "\
-                              "Internal error : Failed to read resource count"
-                        return (False, (404, msg))
-
-                (ok, result) = QuotaHelper.verify_quota_and_create_resource(
-                                          db_conn, obj_dict, obj_type, obj_id,
-                                          quota_limit, self.quota_counter[path])
-                if not ok:
-                    return (ok, result)
-                else:
-                    # To be used for reverting back count when undo() is called
-                    quota_counter.append(self.quota_counter[path])
-            else:
+            #if quota_limit >= 0:
+            #    path = self._path_prefix + proj_uuid + "/" + obj_type
+            #    if not self.quota_counter.get(path):
+            #        # Init quota counter
+            #        path_prefix = self._path_prefix + proj_uuid
+            #        try:
+            #            QuotaHelper._zk_quota_counter_init(
+            #                       path_prefix, {obj_type: quota_limit}, proj_uuid,
+            #                       self._db_conn, self.quota_counter)
+            #        except NoIdError:
+            #            msg = "Error in initializing quota "\
+            #                  "Internal error : Failed to read resource count"
+            #            return (False, (404, msg))
+#
+            #    (ok, result) = QuotaHelper.verify_quota_and_create_resource(
+            #                              db_conn, obj_dict, obj_type, obj_id,
+            #                              quota_limit, self.quota_counter[path])
+            #    if not ok:
+            #        return (ok, result)
+            #    else:
+            #        # To be used for reverting back count when undo() is called
+            #        quota_counter.append(self.quota_counter[path])
+            #else:
                 #normal execution
-                (ok, result) = db_conn.dbe_create(obj_type, obj_id, obj_dict)
-                if not ok:
-                    return (ok, result)
+            (ok, result) = db_conn.dbe_create(obj_type, obj_id, obj_dict)
+            if not ok:
+                return (ok, result)
 
             get_context().set_state('POST_DBE_CREATE')
             # type-specific hook
-            try:
-                ok, result = r_class.post_dbe_create(tenant_name, obj_dict, db_conn)
-            except Exception as e:
-                ok = False
-                msg = ("%s:%s post_dbe_create had an exception: %s\n%s" %
-                       (obj_type, obj_id, str(e),
-                        cfgm_common.utils.detailed_traceback()))
-                result = (None, msg)
-
-            if not ok:
-                # Create is done, log to system, no point in informing user
-                self.config_log(result[1], level=SandeshLevel.SYS_ERR)
+            #try:
+            #    ok, result = r_class.post_dbe_create(tenant_name, obj_dict, db_conn)
+            #except Exception as e:
+            #    ok = False
+            #    msg = ("%s:%s post_dbe_create had an exception: %s\n%s" %
+            #           (obj_type, obj_id, str(e),
+            #            cfgm_common.utils.detailed_traceback()))
+            #    result = (None, msg)
+#
+            #if not ok:
+            #    # Create is done, log to system, no point in informing user
+            #    self.config_log(result[1], level=SandeshLevel.SYS_ERR)
 
             return True, obj_id
         # end stateful_create
@@ -908,42 +908,42 @@
             raise cfgm_common.exceptions.HttpError(code, msg)
 
         # Initialize quota counter if resource is project
-        if resource_type == 'project' and 'quota' in obj_dict:
-            proj_id = obj_dict['uuid']
-            quota_dict = obj_dict.get('quota')
-            path_prefix = self._path_prefix + proj_id
-            if quota_dict:
-                try:
-                    QuotaHelper._zk_quota_counter_init(path_prefix, quota_dict,
-                                          proj_id, db_conn, self.quota_counter)
-                except NoIdError:
-                    err_msg = "Error in initializing quota "\
-                              "Internal error : Failed to read resource count"
-                    self.config_log(err_msg, level=SandeshLevel.SYS_ERR)
+        #if resource_type == 'project' and 'quota' in obj_dict:
+        #    proj_id = obj_dict['uuid']
+        #    quota_dict = obj_dict.get('quota')
+        #    path_prefix = self._path_prefix + proj_id
+        #    if quota_dict:
+        #        try:
+        #            QuotaHelper._zk_quota_counter_init(path_prefix, quota_dict,
+        #                                  proj_id, db_conn, self.quota_counter)
+        #        except NoIdError:
+        #            err_msg = "Error in initializing quota "\
+        #                      "Internal error : Failed to read resource count"
+        #            self.config_log(err_msg, level=SandeshLevel.SYS_ERR)
 
         rsp_body = {}
         rsp_body['name'] = name
         rsp_body['fq_name'] = fq_name
         rsp_body['uuid'] = result
-        rsp_body['href'] = self.generate_url(resource_type, result)
-        if parent_class:
-            # non config-root child, send back parent uuid/href
-            rsp_body['parent_type'] = obj_dict['parent_type']
-            rsp_body['parent_uuid'] = parent_uuid
-            rsp_body['parent_href'] = self.generate_url(parent_res_type,
-                                                        parent_uuid)
-
-        try:
-            self._extension_mgrs['resourceApi'].map_method(
-                'post_%s_create' %(obj_type), obj_dict)
-        except RuntimeError:
-            # lack of registered extension leads to RuntimeError
-            pass
-        except Exception as e:
-            err_msg = 'In post_%s_create an extension had error for %s' \
-                      %(obj_type, obj_dict)
-            err_msg += cfgm_common.utils.detailed_traceback()
-            self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
+        #rsp_body['href'] = self.generate_url(resource_type, result)
+        #if parent_class:
+        #    # non config-root child, send back parent uuid/href
+        #    rsp_body['parent_type'] = obj_dict['parent_type']
+        #    rsp_body['parent_uuid'] = parent_uuid
+        #    #rsp_body['parent_href'] = self.generate_url(parent_res_type,
+        #                                                parent_uuid)
+
+        #try:
+        #    self._extension_mgrs['resourceApi'].map_method(
+        #        'post_%s_create' %(obj_type), obj_dict)
+        #except RuntimeError:
+        #    # lack of registered extension leads to RuntimeError
+        #    pass
+        #except Exception as e:
+        #    err_msg = 'In post_%s_create an extension had error for %s' \
+        #              %(obj_type, obj_dict)
+        #    err_msg += cfgm_common.utils.detailed_traceback()
+        #    self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
 
         return {resource_type: rsp_body}
     # end http_resource_create
@@ -1086,10 +1086,10 @@
 
         obj_dict = get_request().json[resource_type]
 
-        if 'perms2' in obj_dict:
-            if 'owner' not in obj_dict['perms2']:
-                raise cfgm_common.exceptions.HttpError(400,
-                                    'owner in perms2 must be present')
+        #if 'perms2' in obj_dict:
+        #    if 'owner' not in obj_dict['perms2']:
+        #        raise cfgm_common.exceptions.HttpError(400,
+        #                            'owner in perms2 must be present')
 
         fields = r_class.prop_fields | r_class.ref_fields
         try:
@@ -1104,24 +1104,24 @@
 
         # Look if the resource have a pending version, if yes use it as resource
         # to update
-        if hasattr(r_class, 'get_pending_resource'):
-            ok, result = r_class.get_pending_resource(db_obj_dict, fields)
-            if ok and isinstance(result, dict):
-                db_obj_dict = result
-                id = obj_dict['uuid'] = db_obj_dict['uuid']
-            if not ok and result[0] != 404:
-                self.config_object_error(
-                    id, None, obj_type, 'http_resource_update', result[1])
-                raise cfgm_common.exceptions.HttpError(result[0], result[1])
-
-        if resource_type == 'project' and 'quota' in db_obj_dict:
-            old_quota_dict = db_obj_dict['quota']
-        else:
-            old_quota_dict = None
-
+        #if hasattr(r_class, 'get_pending_resource'):
+        #    ok, result = r_class.get_pending_resource(db_obj_dict, fields)
+        #    if ok and isinstance(result, dict):
+        #        db_obj_dict = result
+        #        id = obj_dict['uuid'] = db_obj_dict['uuid']
+        #    if not ok and result[0] != 404:
+        #        self.config_object_error(
+        #            id, None, obj_type, 'http_resource_update', result[1])
+        #        raise cfgm_common.exceptions.HttpError(result[0], result[1])
+
+        #if resource_type == 'project' and 'quota' in db_obj_dict:
+        #    old_quota_dict = db_obj_dict['quota']
+        #else:
+        #    old_quota_dict = None
+#
         self._put_common(
             'http_put', obj_type, id, db_obj_dict, req_obj_dict=obj_dict,
-            quota_dict=old_quota_dict)
+            quota_dict=None)
 
         rsp_body = {}
         rsp_body['uuid'] = id
@@ -3877,127 +3877,127 @@
 
         obj_fq_name = db_obj_dict.get('fq_name', 'missing-fq-name')
         # ZK and rabbitmq should be functional
-        self._ensure_services_conn(
-            api_name, obj_type, obj_uuid, obj_fq_name)
+        #self._ensure_services_conn(
+        #    api_name, obj_type, obj_uuid, obj_fq_name)
 
         resource_type, r_class = self._validate_resource_type(obj_type)
-        try:
-            self._extension_mgrs['resourceApi'].map_method(
-                'pre_%s_update' %(obj_type), obj_uuid, req_obj_dict)
-        except RuntimeError:
-            # lack of registered extension leads to RuntimeError
-            pass
-        except Exception as e:
-            err_msg = 'In pre_%s_update an extension had error for %s' \
-                      %(obj_type, req_obj_dict)
-            err_msg += cfgm_common.utils.detailed_traceback()
-            self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
+        #try:
+        #    self._extension_mgrs['resourceApi'].map_method(
+        #        'pre_%s_update' %(obj_type), obj_uuid, req_obj_dict)
+        #except RuntimeError:
+        #    # lack of registered extension leads to RuntimeError
+        #    pass
+        #except Exception as e:
+        #    err_msg = 'In pre_%s_update an extension had error for %s' \
+        #              %(obj_type, req_obj_dict)
+        #    err_msg += cfgm_common.utils.detailed_traceback()
+        #    self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
 
         db_conn = self._db_conn
 
         # check visibility
-        if (not db_obj_dict['id_perms'].get('user_visible', True) and
-            not self.is_admin_request()):
-            result = 'This object is not visible by users: %s' % obj_uuid
-            self.config_object_error(obj_uuid, None, obj_type, api_name, result)
-            raise cfgm_common.exceptions.HttpError(404, result)
+        #if (not db_obj_dict['id_perms'].get('user_visible', True) and
+        #    not self.is_admin_request()):
+        #    result = 'This object is not visible by users: %s' % obj_uuid
+        #    self.config_object_error(obj_uuid, None, obj_type, api_name, result)
+        #    raise cfgm_common.exceptions.HttpError(404, result)
 
         # properties validator (for collections validation in caller)
-        if req_obj_dict is not None:
-            ok, result = self._validate_props_in_request(r_class,
-                         req_obj_dict, operation='UPDATE')
-            if not ok:
-                result = 'Bad property in %s: %s' %(api_name, result)
-                raise cfgm_common.exceptions.HttpError(400, result)
+        #if req_obj_dict is not None:
+        #    ok, result = self._validate_props_in_request(r_class,
+        #                 req_obj_dict, operation='UPDATE')
+        #    if not ok:
+        #        result = 'Bad property in %s: %s' %(api_name, result)
+        #        raise cfgm_common.exceptions.HttpError(400, result)
 
         # references validator
-        if req_obj_dict is not None:
-            ok, result = self._validate_refs_in_request(r_class, req_obj_dict)
-            if not ok:
-                result = 'Bad reference in %s: %s' %(api_name, result)
-                raise cfgm_common.exceptions.HttpError(400, result)
+        #if req_obj_dict is not None:
+        #    ok, result = self._validate_refs_in_request(r_class, req_obj_dict)
+        #    if not ok:
+        #        result = 'Bad reference in %s: %s' %(api_name, result)
+        #        raise cfgm_common.exceptions.HttpError(400, result)
 
         # common handling for all resource put
         request = get_request()
         fq_name_str = ":".join(obj_fq_name or [])
-        if req_obj_dict:
-            if ('id_perms' in req_obj_dict and
-                    req_obj_dict['id_perms'].get('uuid')):
-                if not self._db_conn.match_uuid(req_obj_dict, obj_uuid):
-                    msg = (
-                        "UUID mismatch from %s:%s" %
-                        (request.environ.get('REMOTE_ADDR',
-                                             "Remote address not found"),
-                         request.environ.get('HTTP_USER_AGENT',
-                                             "User agent not found"))
-                    )
-                    self.config_object_error(
-                        obj_uuid, fq_name_str, obj_type, 'put', msg)
-                    self._db_conn.set_uuid(obj_type, req_obj_dict,
-                                           uuid.UUID(obj_uuid),
-                                           do_lock=False)
-
-            # Ensure object has at least default permissions set
-            self._ensure_id_perms_present(obj_uuid, req_obj_dict)
-
-        apiConfig = VncApiCommon()
-        apiConfig.object_type = obj_type
-        apiConfig.identifier_name = fq_name_str
-        apiConfig.identifier_uuid = obj_uuid
-        apiConfig.operation = api_name
-        self._set_api_audit_info(apiConfig)
-        log = VncApiConfigLog(api_log=apiConfig,
-                sandesh=self._sandesh)
-        log.send(sandesh=self._sandesh)
-
-        if self.is_auth_needed():
-            ok, result = self._permissions.check_perms_write(request, obj_uuid)
-            if not ok:
-                (code, msg) = result
-                self.config_object_error(
-                    obj_uuid, fq_name_str, obj_type, api_name, msg)
-                raise cfgm_common.exceptions.HttpError(code, msg)
+        #if req_obj_dict:
+        #    if ('id_perms' in req_obj_dict and
+        #            req_obj_dict['id_perms'].get('uuid')):
+        #        if not self._db_conn.match_uuid(req_obj_dict, obj_uuid):
+        #            msg = (
+        #                "UUID mismatch from %s:%s" %
+        #                (request.environ.get('REMOTE_ADDR',
+        #                                     "Remote address not found"),
+        #                 request.environ.get('HTTP_USER_AGENT',
+        #                                     "User agent not found"))
+        #            )
+        #            self.config_object_error(
+        #                obj_uuid, fq_name_str, obj_type, 'put', msg)
+        #            self._db_conn.set_uuid(obj_type, req_obj_dict,
+        #                                   uuid.UUID(obj_uuid),
+        #                                   do_lock=False)
+#
+        #    # Ensure object has at least default permissions set
+        self._ensure_id_perms_present(obj_uuid, req_obj_dict)
+
+        #apiConfig = VncApiCommon()
+        #apiConfig.object_type = obj_type
+        #apiConfig.identifier_name = fq_name_str
+        #apiConfig.identifier_uuid = obj_uuid
+        #apiConfig.operation = api_name
+        #self._set_api_audit_info(apiConfig)
+        #log = VncApiConfigLog(api_log=apiConfig,
+        #        sandesh=self._sandesh)
+        #log.send(sandesh=self._sandesh)
+#
+        #if self.is_auth_needed():
+        #    ok, result = self._permissions.check_perms_write(request, obj_uuid)
+        #    if not ok:
+        #        (code, msg) = result
+        #        self.config_object_error(
+        #            obj_uuid, fq_name_str, obj_type, api_name, msg)
+        #        raise cfgm_common.exceptions.HttpError(code, msg)
 
         # Validate perms on references
-        if req_obj_dict is not None:
-            try:
-                self._validate_perms_in_request(
-                    r_class, obj_type, req_obj_dict)
-            except NoIdError:
-                raise cfgm_common.exceptions.HttpError(400,
-                    'Unknown reference in resource update %s %s.'
-                    %(obj_type, req_obj_dict))
-
-        # State modification starts from here. Ensure that cleanup is done for all state changes
+        #if req_obj_dict is not None:
+        #    try:
+        #        self._validate_perms_in_request(
+        #            r_class, obj_type, req_obj_dict)
+        #    except NoIdError:
+        #        raise cfgm_common.exceptions.HttpError(400,
+        #            'Unknown reference in resource update %s %s.'
+        #            %(obj_type, req_obj_dict))
+#
+        ## State modification starts from here. Ensure that cleanup is done for all state changes
         cleanup_on_failure = []
         if req_obj_dict is not None:
             req_obj_dict['uuid'] = obj_uuid
 
         # Permit abort resource update and retrun 202 status code
         get_context().set_state('PENDING_DBE_UPDATE')
-        ok, result = r_class.pending_dbe_update(db_obj_dict, req_obj_dict,
-                                                req_prop_coll_updates)
-        if not ok:
-            code, msg = result
-            raise cfgm_common.exceptions.HttpError(code, msg)
-        if ok and isinstance(result, tuple) and result[0] == 202:
-            # Modifications accepted but not applied, pending update
-            # returns 202 HTTP OK code to aware clients
-            bottle.response.status = 202
-            return True, ''
-
+        #ok, result = r_class.pending_dbe_update(db_obj_dict, req_obj_dict,
+        #                                        req_prop_coll_updates)
+        #if not ok:
+        #    code, msg = result
+        #    raise cfgm_common.exceptions.HttpError(code, msg)
+        #if ok and isinstance(result, tuple) and result[0] == 202:
+        #    # Modifications accepted but not applied, pending update
+        #    # returns 202 HTTP OK code to aware clients
+        #    bottle.response.status = 202
+        #    return True, ''
+#
         def stateful_update():
             get_context().set_state('PRE_DBE_UPDATE')
             # type-specific hook
-            (ok, result) = r_class.pre_dbe_update(
-                obj_uuid, obj_fq_name, req_obj_dict or {}, self._db_conn,
-                prop_collection_updates=req_prop_coll_updates)
-            if not ok:
-                return (ok, result)
+            #(ok, result) = r_class.pre_dbe_update(
+            #    obj_uuid, obj_fq_name, req_obj_dict or {}, self._db_conn,
+            #    prop_collection_updates=req_prop_coll_updates)
+            #if not ok:
+            #    return (ok, result)
             attr_to_publish = None
-            if isinstance(result, dict):
-                attr_to_publish = result
-
+            #if isinstance(result, dict):
+            #    attr_to_publish = result
+#
             get_context().set_state('DBE_UPDATE')
             if api_name == 'ref-update':
                 # read ref_update args
@@ -4026,18 +4026,18 @@
                     attr_to_publish=attr_to_publish,
                 )
                 # Update quota counter
-                if resource_type == 'project' and 'quota' in req_obj_dict:
-                    proj_id = req_obj_dict['uuid']
-                    quota_dict = req_obj_dict['quota']
-                    path_prefix = self._path_prefix + proj_id
-                    try:
-                        QuotaHelper._zk_quota_counter_update(
-                                   path_prefix, quota_dict, proj_id, db_conn,
-                                   self.quota_counter)
-                    except NoIdError:
-                        msg = "Error in initializing quota "\
-                              "Internal error : Failed to read resource count"
-                        self.config_log(msg, level=SandeshLevel.SYS_ERR)
+                #if resource_type == 'project' and 'quota' in req_obj_dict:
+                #    proj_id = req_obj_dict['uuid']
+                #    quota_dict = req_obj_dict['quota']
+                #    path_prefix = self._path_prefix + proj_id
+                #    try:
+                #        QuotaHelper._zk_quota_counter_update(
+                #                   path_prefix, quota_dict, proj_id, db_conn,
+                #                   self.quota_counter)
+                #    except NoIdError:
+                #        msg = "Error in initializing quota "\
+                #              "Internal error : Failed to read resource count"
+                #        self.config_log(msg, level=SandeshLevel.SYS_ERR)
             elif req_prop_coll_updates:
                 (ok, result) = db_conn.prop_collection_update(
                     obj_type,
@@ -4050,12 +4050,12 @@
 
             get_context().set_state('POST_DBE_UPDATE')
             # type-specific hook
-            (ok, result) = r_class.post_dbe_update(
-                obj_uuid, obj_fq_name, req_obj_dict or {}, self._db_conn,
-                prop_collection_updates=req_prop_coll_updates)
-            if not ok:
-                return (ok, result)
-
+            #(ok, result) = r_class.post_dbe_update(
+            #    obj_uuid, obj_fq_name, req_obj_dict or {}, self._db_conn,
+            #    prop_collection_updates=req_prop_coll_updates)
+            #if not ok:
+            #    return (ok, result)
+#
             return (ok, result)
         # end stateful_update
 
@@ -4083,18 +4083,18 @@
             code, msg = result
             raise cfgm_common.exceptions.HttpError(code, msg)
 
-        try:
-            self._extension_mgrs['resourceApi'].map_method(
-                'post_%s_update' %(obj_type), obj_uuid,
-                 req_obj_dict, db_obj_dict)
-        except RuntimeError:
-            # lack of registered extension leads to RuntimeError
-            pass
-        except Exception as e:
-            err_msg = 'In post_%s_update an extension had error for %s' \
-                      %(obj_type, req_obj_dict)
-            err_msg += cfgm_common.utils.detailed_traceback()
-            self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
+        #try:
+        #    self._extension_mgrs['resourceApi'].map_method(
+        #        'post_%s_update' %(obj_type), obj_uuid,
+        #         req_obj_dict, db_obj_dict)
+        #except RuntimeError:
+        #    # lack of registered extension leads to RuntimeError
+        #    pass
+        #except Exception as e:
+        #    err_msg = 'In post_%s_update an extension had error for %s' \
+        #              %(obj_type, req_obj_dict)
+        #    err_msg += cfgm_common.utils.detailed_traceback()
+        #    self.config_log(err_msg, level=SandeshLevel.SYS_NOTICE)
     # end _put_common
 
     # parent_type needed for perms check. None for derived objects (eg.
@@ -4207,47 +4207,47 @@
         except NoIdError:
             pass
 
-        self.validate_parent_type(obj_type, obj_dict)
-        # Ensure object has at least default permissions set
+        #self.validate_parent_type(obj_type, obj_dict)
+        ## Ensure object has at least default permissions set
         self._ensure_id_perms_present(None, obj_dict)
-        self._ensure_perms2_present(obj_type, None, obj_dict,
-            get_request().headers.environ.get('HTTP_X_PROJECT_ID', None))
+        #self._ensure_perms2_present(obj_type, None, obj_dict,
+        #    get_request().headers.environ.get('HTTP_X_PROJECT_ID', None))
 
         # TODO check api + resource perms etc.
 
         uuid_in_req = obj_dict.get('uuid', None)
 
-        # Set the display name
-        if (('display_name' not in obj_dict) or
-            (obj_dict['display_name'] is None)):
-            obj_dict['display_name'] = obj_dict['fq_name'][-1]
-
-        fq_name_str = ":".join(obj_dict['fq_name'])
-        apiConfig = VncApiCommon()
-        apiConfig.object_type = obj_type
-        apiConfig.identifier_name=fq_name_str
-        apiConfig.identifier_uuid = uuid_in_req
-        apiConfig.operation = 'post'
-        try:
-            body = json.dumps(get_request().json)
-        except:
-            body = str(get_request().json)
-        apiConfig.body = body
-        if uuid_in_req:
-            if uuid_in_req != str(uuid.UUID(uuid_in_req)):
-                bottle.abort(400, 'Invalid UUID format: ' + uuid_in_req)
-            try:
-                fq_name = self._db_conn.uuid_to_fq_name(uuid_in_req)
-                raise cfgm_common.exceptions.HttpError(
-                    409, uuid_in_req + ' already exists with fq_name: ' +
-                    pformat(fq_name))
-            except NoIdError:
-                pass
-            apiConfig.identifier_uuid = uuid_in_req
-
-        self._set_api_audit_info(apiConfig)
-        log = VncApiConfigLog(api_log=apiConfig, sandesh=self._sandesh)
-        log.send(sandesh=self._sandesh)
+        ## Set the display name
+        #if (('display_name' not in obj_dict) or
+        #    (obj_dict['display_name'] is None)):
+        #    obj_dict['display_name'] = obj_dict['fq_name'][-1]
+#
+        #fq_name_str = ":".join(obj_dict['fq_name'])
+        #apiConfig = VncApiCommon()
+        #apiConfig.object_type = obj_type
+        #apiConfig.identifier_name=fq_name_str
+        #apiConfig.identifier_uuid = uuid_in_req
+        #apiConfig.operation = 'post'
+        #try:
+        #    body = json.dumps(get_request().json)
+        #except:
+        #    body = str(get_request().json)
+        #apiConfig.body = body
+        #if uuid_in_req:
+        #    if uuid_in_req != str(uuid.UUID(uuid_in_req)):
+        #        bottle.abort(400, 'Invalid UUID format: ' + uuid_in_req)
+        #    try:
+        #        fq_name = self._db_conn.uuid_to_fq_name(uuid_in_req)
+        #        raise cfgm_common.exceptions.HttpError(
+        #            409, uuid_in_req + ' already exists with fq_name: ' +
+        #            pformat(fq_name))
+        #    except NoIdError:
+        #        pass
+        #    apiConfig.identifier_uuid = uuid_in_req
+#
+        #self._set_api_audit_info(apiConfig)
+        #log = VncApiConfigLog(api_log=apiConfig, sandesh=self._sandesh)
+        #log.send(sandesh=self._sandesh)
 
         return (True, uuid_in_req)
     # end _post_common
diff -Naur -x '*.pyc' site-packages_orig/vnc_cfg_api_server/vnc_db.py site-packages/vnc_cfg_api_server/vnc_db.py
--- site-packages_orig/vnc_cfg_api_server/vnc_db.py	2018-07-12 04:35:21.000000000 +0200
+++ site-packages/vnc_cfg_api_server/vnc_db.py	2018-08-22 17:03:10.951417981 +0200
@@ -1283,8 +1283,8 @@
 
                 # many updates don't touch perms2
                 new_perms2 = obj_dict.get('perms2', None)
-                if not new_perms2:
-                    return (ok, result)
+               
+                return (ok, result)
 
                 share_perms = new_perms2.get('share', cur_perms2['share'])
                 global_access = new_perms2.get('global_access', cur_perms2['global_access'])
