diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/cfgm_common/vnc_etcd.py new/site-packages/cfgm_common/vnc_etcd.py
--- orig/site-packages/cfgm_common/vnc_etcd.py	1970-01-01 01:00:00.000000000 +0100
+++ new/site-packages/cfgm_common/vnc_etcd.py	2018-10-23 14:42:22.000000000 +0200
@@ -0,0 +1,640 @@
+#
+# Copyright (c) 2018 Juniper Networks, Inc. All rights reserved.
+#
+import datetime
+import json
+import uuid
+from functools import wraps
+
+import etcd3
+from etcd3.client import KVMetadata
+import time
+import utils
+from cfgm_common.exceptions import DatabaseUnavailableError, NoIdError, VncError
+from etcd3.exceptions import ConnectionFailedError
+from six.moves import queue
+from pysandesh.connection_info import ConnectionState
+from pysandesh.gen_py.process_info.ttypes import ConnectionStatus
+from pysandesh.gen_py.process_info.ttypes import ConnectionType as ConnType
+from pysandesh.gen_py.sandesh.ttypes import SandeshLevel
+
+from cfgm_common import vnc_greenlets
+from cfgm_common.vnc_amqp import VncAmqpHandle
+
+from vnc_api import vnc_api
+
+def etcd_args(args):
+    host, port = args.etcd_server.split(":")
+    vnc_db = {
+        'host': host,
+        'port': port,
+        'prefix': args.etcd_prefix,
+    }
+    if args.etcd_user and args.etcd_password:
+        credentials = {'user': args.etcd_user,
+                       'password': args.etcd_password}
+
+        if args.ssl_enabled:
+            credentials['ca_cert'] = args.etcd_ssl_ca_cert
+            credentials['cert_key'] = args.etcd_ssl_keyfile
+            credentials['cert_cert'] = args.etcd_ssl_certfile
+
+        vnc_db['credentials'] = credentials
+
+    return vnc_db
+
+def _handle_conn_error(func):
+    @wraps(func)
+    def wrapper(self, *args, **kwargs):
+        start_time = datetime.datetime.now()
+        try:
+            return func(self, *args, **kwargs)
+        except ConnectionFailedError as exc:
+            if self._logger:
+                msg = 'etcd connection down. Exception in {}'.format(str(func))
+                self._logger(msg, level=SandeshLevel.SYS_ERR)
+            raise DatabaseUnavailableError(
+                'Error, %s: %s' % (str(exc), utils.detailed_traceback()))
+        finally:
+            if self.log_response_time:
+                end_time = datetime.datetime.now()
+                self.log_response_time(end_time - start_time)
+    return wrapper
+
+
+class VncEtcdClient(object):
+    def __init__(self, host, port, credentials):
+        self._host = host
+        self._port = port
+        self._credentials = credentials
+        self._conn_state = ConnectionStatus.INIT
+
+        self._client = self._new_client()
+
+    def _new_client(self):
+        kwargs = {'host': self._host, 'port': self._port}
+
+        if self._credentials:
+            kwargs.update(self._credentials)
+
+        client = etcd3.client(timeout=5, **kwargs)
+        self._update_sandesh_status(ConnectionStatus.UP)
+
+        return client
+
+    def _update_sandesh_status(self, status, msg=''):
+        self._conn_state = status
+        ConnectionState.update(conn_type=ConnType.DATABASE,
+                               name='etcd', status=status, message=msg,
+                               server_addrs=["{}:{}".format(self._host, self._port)])
+
+
+def gen_request_id():
+    return "req-%s" % uuid.uuid4()
+
+
+class VncEtcdWatchHandle(VncAmqpHandle):
+    def __init__(self, sandesh, logger, db_cls, reaction_map,
+                 notifier_cfg, trace_file=None, timer_obj=None):
+        self._etcd_cfg = notifier_cfg
+        super(VncEtcdWatchHandle, self).__init__(
+            sandesh, logger, db_cls, reaction_map, q_name_prefix=None,
+            rabbitmq_cfg=None, trace_file=trace_file, timer_obj=timer_obj)
+
+    def establish(self):
+        self._vnc_etcd_watcher = VncEtcdWatchClient(
+                self._etcd_cfg['host'], self._etcd_cfg['port'],
+                self._etcd_cfg.get('credentials'), self._etcd_cfg['prefix'],
+                self._etcd_callback_wrapper, self.logger.log)
+
+    def _etcd_callback_wrapper(self, event):
+        self.logger.debug("Got etcd event: {}".format(event))
+        common_msg = self._parse_event(event)
+        self.logger.debug("Got etcd msg: {}".format(common_msg))
+        self._vnc_subscribe_callback(common_msg)
+
+    def _parse_event(self, event):
+        obj_type, uuid = event.key.split("/")[-2:]
+        oper = self._get_oper(event)
+        msg = {"type": obj_type, "uuid": uuid, "oper": oper}
+        if oper == "CREATE":
+            msg["obj_dict"] = json.loads(event.value)
+        msg["request_id"] = gen_request_id()
+
+        return msg
+
+    @staticmethod
+    def _get_oper(event):
+        e = event._event
+        # oper_name = e.EventType.DESCRIPTOR.values_by_number[e.type].name
+        if isinstance(event, etcd3.events.PutEvent):
+            if KVMetadata(e.kv, None).version == 1:
+                return "CREATE"
+            return "UPDATE"
+        return "DELETE"
+
+    def close(self):
+        self._vnc_etcd_watcher.shutdown()
+
+
+class VncEtcdWatchClient(VncEtcdClient):
+    def __init__(self, host, port, credentials, prefix, subscribe_cb, logger):
+        self._prefix = prefix
+        self.subscribe_cb = subscribe_cb
+        self._logger = logger
+
+        self._cancel = None
+
+        super(VncEtcdWatchClient, self).__init__(host, port, credentials)
+
+        self._start(self._prefix)
+
+    def _reconnect(self):
+        msg = "etcd connection DOWN"
+        self._logger(msg, level=SandeshLevel.SYS_NOTICE)
+        self._update_sandesh_status(ConnectionStatus.DOWN)
+
+        if self._cancel is not None:
+            self._cancel()
+            self._cancel = None
+            self._consumer = None
+
+        self._client = self._new_client()
+
+        #self._update_sandesh_status(ConnectionStatus.UP)
+        msg = 'etcd connection ESTABLISHED %s' % repr(self._client)
+        self._logger(msg, level=SandeshLevel.SYS_NOTICE)
+
+        self._consumer, self._cancel = self._client.watch_prefix(self._prefix)
+
+
+    def _connection_watch(self, connected):
+        if not connected:
+            self._reconnect()
+
+        while True:
+            try:
+                self.subscribe_cb(next(self._consumer))
+                # self._conn.drain_events()
+            except Exception as e:  # self._conn.connection_errors + self._conn.channel_errors as e:
+                msg = "Error in etcd watch greenlet: {}".format(e)
+                self._logger(msg, level=SandeshLevel.SYS_ERR)
+                self._reconnect()
+
+    def _connection_watch_forever(self):
+        connected = True
+        while True:
+            try:
+                self._connection_watch(connected)
+            except Exception as e:
+                msg = 'Error in etcd drainer greenlet: %s' % (str(e))
+                self._logger(msg, level=SandeshLevel.SYS_ERR)
+                # avoid 'reconnect()' here as that itself might cause exception
+                connected = False
+
+    def _start(self, client_name):
+        self._reconnect()
+
+        self._connection_monitor_greenlet = vnc_greenlets.VncGreenlet(
+            'etcd_ ' + client_name + '_ConnMon',
+            self._connection_watch_forever)
+
+    def greenlets(self):
+        ret = [self._connection_monitor_greenlet]
+        return ret
+
+    def shutdown(self):
+        self._connection_monitor_greenlet.kill()
+        if self._consumer:
+            self._cancel()
+
+class VncEtcd(VncEtcdClient):
+    def __init__(self, host, port, prefix, logger=None,
+                 obj_cache_exclude_types=None, log_response_time=None,
+                 credentials=None):
+        super(VncEtcd, self).__init__(host, port, credentials)
+        self._prefix = prefix
+        self._logger = logger
+        self.log_response_time = log_response_time
+        self.timeout = 5
+
+        # cache for object_read, object_list and object_all
+        self._obj_cache = EtcdCache(skip_keys=obj_cache_exclude_types)
+        # general purposes cache
+        self._cache = EtcdCache(ttl=3600)  # 1 hour TTL
+
+    def __getattr__(self, name):
+        return getattr(self._client, name)
+
+    def _key_prefix(self, obj_type):
+        """Resources prefix for etcd.
+
+        :param (str) obj_type: Type of resource
+        :return: (str) full prefix ie: "/contrail/virtual_network"
+        """
+        return "{prefix}/{type}/".format(prefix=self._prefix, type=obj_type)
+
+    def _key_obj(self, obj_type, obj_id):
+        """Resource key with resource prefix.
+
+        :param (str) obj_type: Type of resource
+        :param (str) obj_id: uuid of object
+        :return: (str) full key ie: "/contrail/virtual_network/aaa-bbb-ccc"
+        """
+        key_prefix = self._key_prefix(obj_type)
+        return "{prefix}{id}".format(prefix=key_prefix, id=obj_id)
+
+    @_handle_conn_error
+    def object_read(self, obj_type, obj_uuids, field_names=None,
+                    ret_readonly=False):
+        """Read objects from etcd.
+
+        :param (str) obj_type: Resource type.
+        :param (List[str]) obj_uuids: List of UUID to fetch.
+        :param (List[str]) field_names: List of fields to return.
+        :param (boolean) ret_readonly: If True read resource
+                                       from cache when possible.
+        :return: (List[Dict]) List of resources.
+        """
+        results = []
+        if not obj_uuids:
+            return True, results
+
+        for uuid in obj_uuids:
+            key = self._key_obj(obj_type, uuid)
+            if ret_readonly is True and key in self._obj_cache:
+                record = self._obj_cache[key]
+                resource = record.resource
+            else:
+                resource = self._watch_once(key)
+                if resource is None:
+                    # There is no data in etcd, go to next uuid
+                    continue
+
+                resource = self._patch_refs_to(json.loads(resource))
+                record = EtcdCache.Record(resource=resource)
+                self._obj_cache[key] = record
+
+            if field_names is None:
+                results.append(resource)
+            else:
+                results.append({k: v for k, v in resource.items()
+                                if k in field_names})
+
+        if not results:
+            raise NoIdError(obj_uuids[0])
+        return True, results
+
+    @_handle_conn_error
+    def object_all(self, obj_type):
+        """Get all objects for given type.
+
+        :param (str) obj_type: Type of resource object
+        :return: (gen) Generator with dict resources
+        """
+        key = self._key_prefix(obj_type)
+        response = self._client.get_prefix(key)
+        return (self._patch_refs_to(json.loads(resp[0])) for resp in response)
+
+    @_handle_conn_error
+    def object_list(self, obj_type, parent_uuids=None, back_ref_uuids=None,
+                    obj_uuids=None, count=False, filters=None,
+                    paginate_start=None, paginate_count=None):
+        """Get list of objects uuid.
+
+        For given parent_uuids find all uuids of children with type 'obj_type'
+        and for given back_ref_uuids find all backrefs type of obj_type.
+
+        :param (str) obj_type: Type of resource object
+        :param (List[str]) parent_uuids: List of parents uuid
+        :param (List[str]) back_ref_uuids: List of backrefs uuid
+        :param (List[str]) obj_uuids: If exists is used as filter.
+                           Only obj which are in this list will be returned.
+        :param (boolean) count: If true, return length of resources
+        :param (dict) filters: Filters to apply on results
+        :param (str) paginate_start: Last uuid from previous fetch
+        :param (int) paginate_count: The maximum number of uuids to fetch
+        :return: (Tuple[boolean, List[str], str]) Tuple with success state,
+                 list of uuids and last uuid in current fetch
+        """
+        # prepare filters
+        if hasattr(self, '_db_client_mgr'):
+            obj_class = self._db_client_mgr.get_resource_class(obj_type)
+        else:
+            obj_class = getattr(vnc_api, utils.CamelCase(obj_type))
+        if filters is not None:
+            filters = [f for f in filters if f in obj_class.prop_fields]
+        # end prepare filters
+
+        # map obj_type to field in etcd record
+        backref_field = {'children': "{}s".format(obj_type),
+                         'backrefs': "{}_backrefs".format(obj_type)}
+
+        results = []  # list of dicts from etcd
+        for field, uuids in (('children', parent_uuids),
+                             ('backrefs', back_ref_uuids)):
+            if uuids:
+                _, parents = self.object_read(obj_type, uuids,
+                                              ret_readonly=True)
+                backrefs = self._get_backrefs(parents, obj_type,
+                                              backref_field[field])
+                filtered = self._filter(backrefs, obj_uuids, filters=filters)
+                results.extend(filtered)
+
+        anchored_op = True
+        if not parent_uuids and not back_ref_uuids:
+            anchored_op = False
+            if obj_uuids:
+                # take obj_uuids and apply filters
+                _, parents = self.object_read(obj_type, obj_uuids,
+                                              ret_readonly=True)
+                for field in backref_field.keys():
+                    backrefs = self._get_backrefs(parents, obj_type,
+                                                  backref_field[field])
+                    filtered = self._filter(backrefs, filters=filters)
+                    results.extend(filtered)
+            else:
+                # grab all resources of obj_type
+                results.extend(self.object_all(obj_type))
+
+        if count:
+            return True, len(results), None
+
+        ret_marker = None  # last item for pagination
+        if paginate_start and anchored_op:
+            results, ret_marker = self._paginate(results, paginate_start,
+                                                 paginate_count)
+
+        return True, [(True, r['uuid']) for r in results], ret_marker
+
+    def fq_name_to_uuid(self, obj_type, fq_name):
+        """Get uuid from fully qualified name.
+
+        :param (str) obj_type: Type of resource
+        :param (List[str]) fq_name:
+        :return: (str) uuid
+        """
+        fq_name_str = utils.encode_string(':'.join(fq_name))
+        prefix = self._key_prefix(obj_type)
+
+        key = "{}{}".format(prefix, fq_name_str)
+        if key in self._cache:
+            record = self._cache[key]
+        else:
+            response, _ = self._client.get_prefix(prefix)
+            record = None
+            for data, _ in response:
+                obj = json.loads(data)
+                obj_fq_name = utils.encode_string(':'.join(obj['fq_name']))
+                if obj_fq_name == fq_name_str:
+                    if record is not None:
+                        msg = 'Multi match {} for {}'
+                        raise VncError(msg.format(fq_name_str, obj_type))
+                    record = EtcdCache.Record(resource=obj)
+            if record is None:
+                raise NoIdError('{} {}'.format(obj_type, fq_name_str))
+            self._cache[key] = record
+
+        return record.resource['uuid']
+
+    def uuid_to_fq_name(self, uuid):
+        """Get fully qualified name of object with given uuid.
+
+        :param (str) uuid:
+        :return: (List[str]) fq_name
+        """
+        if uuid in self._cache:
+            record = self._cache[uuid]
+        else:
+            response = self._client.get_prefix(self._prefix)
+            for data, _ in response:
+                obj = json.loads(data)
+                if obj['uuid'] == uuid:
+                    record = EtcdCache.Record(resource=obj)
+                    break
+            else:
+                raise NoIdError(uuid)
+            self._cache[uuid] = record
+
+        return record.resource['fq_name']
+
+    def cache_uuid_to_fq_name_add(self, id, fq_name, obj_type):
+        """vnc_etcd handle Cache in different way than vnc_cassandra.
+        This method is just for compatibility.
+        """
+        pass
+
+    def _watch_once(self, key):
+        """
+        """
+        event_queue = queue.Queue()
+        def callback(event):
+            event_queue.put(event)
+        watch_id = self.add_watch_callback(key, callback, None)
+        resource, _ = self._client.get(key)
+        if resource is None:
+            try:
+                ev = event_queue.get(self.timeout)
+                resource = ev.value
+            except queue.Empty:
+                pass
+            finally:
+                self.cancel_watch(watch_id)
+
+        return resource
+
+    def _patch_refs_to(self, obj):
+        """Add missing key "to" for every ref in object.
+        This is required for backward compatibility.
+
+        :param (dict) obj: Vanilla object from etcd
+        :return: (dict) Obj with patched 'to' key
+        """
+        for key in obj.keys():
+            if key.endswith('_refs'):
+                for ref in obj[key]:
+                    if 'to' not in ref:
+                        ref['to'] = self.uuid_to_fq_name(ref['uuid'])
+        return obj
+
+    def _get_backrefs(self, parents, obj_type, field):
+        """Fetch all backrefs from given field.
+
+        :param (List[Dict]) parents: List of objects
+        :param (str) obj_type: Type of resource
+        :param (str) field: Field with child resources
+        :return: (gen) Generator of dicts with fetched objects
+        """
+        for parent in parents:
+            if field in parent:
+                for element in parent[field]:
+                    _, backref = self.object_read(obj_type, [element['uuid']],
+                                                  ret_readonly=True)
+                    yield backref
+
+    def _filter(self, objs, obj_uuids=None, filters=None):
+        """Filter objects by applying filters.
+
+        Object will pass the test if fully match the filter.
+
+        :param (List[Dict]) objs: Objects to filter
+        :param (List[str]) obj_uuids: If exists is used as filter.
+                           Only obj which are in this list will be returned.
+        :param (Dict) filters: Dictionary with lists of filters
+                               under each field.
+        :return: (List[Dict]) List of objects which passed filters
+        """
+        for obj in objs:
+            if obj_uuids and obj['uuid'] not in obj_uuids:
+                continue
+
+            if not filters:
+                yield obj
+            else:
+                yield_obj = True
+                for k, v in filters.items():
+                    # search for the first mismatch
+                    if k not in obj:
+                        yield_obj = False
+                        break
+                    elif k in obj and isinstance(obj[k], dict):
+                        for f in v:
+                            try:
+                                f_dict = json.loads(f)
+                            except ValueError:
+                                continue
+                            if f_dict.viewitems() ^ obj[k].viewitems():
+                                yield_obj = False
+                                break
+
+                    if yield_obj is False:
+                        break
+
+                if yield_obj:
+                    yield obj
+
+    def _paginate(self, objs, paginate_start, paginate_count):
+        """Paginate object list.
+
+        :param (List[Dict]) objs: List of objects to paginate
+        :param (str) paginate_start: Last uuid from previous page
+        :param (int) paginate_count: How much to show on page
+        :return: (Tuple[List[Dict], str]) Current page of objects and last uuid
+        """
+        result = list(sorted(objs, key=lambda x: x['id_perms']['created']))
+        try:
+            # result holds list of objects, but we need to find
+            # index of first item by uuid
+            idx_start = [x['uuid'] for x in result].index(paginate_start)
+        except ValueError:
+            idx_start = 0
+        result = result[idx_start:]
+
+        if len(objs) > paginate_count:
+            result = result[:paginate_count]
+        ret_marker = None if not result else result[-1]['uuid']
+        return result, ret_marker
+
+
+class EtcdCache(object):
+    """etcd cache container with TTL records.
+
+    :param ttl (int): Time To Live of records expressed in seconds.
+    :param skip_keys: List of object types which should not be cached.
+    :example:
+
+        # create cache instance
+        cache = EtcdCache(ttl=500, skip_keys=['tag_type'])
+
+        # write record to cache
+        key = '/contrail/virtual_network/5ee45236-c435-4006-b4df-ba3442c8a3ec'
+        resource, kv_meta = etcd_client.get(key)
+        record = EtcdCache.Record(resource=resource, kv_meta=kv_meta)
+
+        cache[key] = record
+
+        # read record from cache
+        if key in cache:
+            record = cache[key]
+            print(record.resource, record.ttl)
+    """
+    DEFAULT_TTL = 300  # seconds
+
+    class Record(object):
+        """Record interface to use in cache.
+
+        :param (int) ttl: Time to live in seconds
+        :param (Any) resource: data to store, typically a dictionary
+        :param (etcd3.KVMetadata) kv_meta: Meta data from etcd3 client
+        """
+
+        def __init__(self, ttl=None, resource=None, kv_meta=None):
+            self.ttl = ttl
+            self.resource = resource
+            self.kv_meta = kv_meta
+
+        def set_ttl(self, sec):
+            """Set Time To Live in record.
+
+            Will use TTL from cache container. Can be used to variate
+            TTL for every record individually.
+
+            :param (int) sec: How long in seconds this record stays valid
+            """
+            self.ttl = datetime.datetime.now() + datetime.timedelta(seconds=sec)
+
+    def __init__(self, ttl=None, skip_keys=None):
+        self._data = {}
+        self._skip_keys = skip_keys if skip_keys is not None else []
+        if ttl and isinstance(ttl, int):
+            self._ttl = ttl
+        else:
+            self._ttl = self.DEFAULT_TTL
+
+    def __contains__(self, key):
+        """Attempt check if key exists in cache.
+
+        Will try to revoke key if ttl expired, and then return True
+        if key is valid and still exist in cache, otherwise will return False.
+        """
+        self.revoke_ttl(key)
+        return key in self._data
+
+    def __getitem__(self, key):
+        """Read record from cache.
+
+        Throws KeyError if key doesn't exist.
+        """
+        self.revoke_ttl(key)
+        return self._data[key]
+
+    def __setitem__(self, key, record):
+        """Write new record or replace existing one.
+
+        Write method expects record to be instance of Record.
+        If record type is in skip_keys will not be write to cache.
+        """
+        if not isinstance(record, self.Record):
+            msg = "{} expect record to be instance of {}".format(
+                self.__class__.__name__, self.Record.__name__)
+            raise TypeError(msg)
+
+        for skip in self._skip_keys:
+            if skip in key:
+                return
+
+        record.set_ttl(self._ttl)
+        self._data[key] = record
+
+    def __delitem__(self, key):
+        """Revoke key if exists in cache."""
+        if key in self._data:
+            del self._data[key]
+
+    def revoke_ttl(self, key):
+        """Revoke key if TTL expired."""
+        if key in self._data:
+            now = datetime.datetime.now()
+            record = self._data[key]
+            if record.ttl < now:
+                del self[key]
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/cfgm_common/vnc_object_db.py new/site-packages/cfgm_common/vnc_object_db.py
--- orig/site-packages/cfgm_common/vnc_object_db.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/cfgm_common/vnc_object_db.py	2018-10-22 16:09:09.000000000 +0200
@@ -7,11 +7,13 @@
 """
 
 import vnc_cassandra
+import vnc_etcd
+
 
 class VncObjectDBClient(object):
     def __init__(self, server_list=None, db_prefix=None, rw_keyspaces=None,
                  ro_keyspaces=None, logger=None, generate_url=None,
-                 reset_config=False, credential=None, walk=True,
+                 reset_config=False, credentials=None, walk=True,
                  obj_cache_entries=0, obj_cache_exclude_types=None,
                  debug_obj_cache_types=None, connection=None,
                  db_engine='cassandra', ssl_enabled=False, ca_certs=None):
@@ -24,7 +26,7 @@
                     logger,
                     generate_url,
                     reset_config,
-                    credential,
+                    credentials,
                     walk,
                     obj_cache_entries,
                     obj_cache_exclude_types,
@@ -40,3 +42,17 @@
 
     def __getattr__(self, name):
         return getattr(self._object_db, name)
+
+
+class VncObjectEtcdClient(object):
+    def __init__(self, host, port, prefix, logger, credentials=None):
+        self._object_db = vnc_etcd.VncEtcd(
+            host=host, port=port, prefix=prefix, logger=logger,
+            obj_cache_exclude_types=[], credentials=credentials)
+
+    def __getattr__(self, name):
+        if not hasattr(self._object_db, name):
+            # TODO(pawel.zadrozny) remove this check when etcd is fully adopted
+            msg = ("VNC ETCD does not implement method '%s'" % name)
+            raise NotImplementedError(msg)
+        return getattr(self._object_db, name)
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/common/args.py new/site-packages/kube_manager/common/args.py
--- orig/site-packages/kube_manager/common/args.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/common/args.py	2018-10-22 16:09:09.000000000 +0200
@@ -106,15 +106,25 @@
         'kombu_ssl_keyfile': '',
         'kombu_ssl_certfile': '',
         'kombu_ssl_ca_certs': '',
+        'notification_driver': 'rabbit',
+        'db_driver': 'cassandra',
         'cassandra_user': None,
         'cassandra_password': None,
         'cassandra_server_list': '',
+        'etcd_user': None,
+        'etcd_password': None,
+        'etcd_server': '127.0.0.1:2379',
+        'etcd_prefix': '/contrail',
+        'etcd_use_ssl': False,
+        'etcd_ssl_keyfile': '',
+        'etcd_ssl_certfile': '',
+        'etcd_ssl_ca_certs': '',
         'cluster_id': '',
         'vnc_endpoint_ip': '[127.0.0.1]',
         'vnc_endpoint_port': ApiServerPort,
-        'admin_user' : '',
-        'admin_password' : '',
-        'admin_tenant' : '',
+        'admin_user': '',
+        'admin_password': '',
+        'admin_tenant': '',
         'public_fip_pool': '{}',
         'zk_server_ip': '127.0.0.1:2181',
     }
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/__init__.py new/site-packages/kube_manager/__init__.py
--- orig/site-packages/kube_manager/__init__.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/__init__.py	2018-10-22 16:09:09.000000000 +0200
@@ -1,3 +1,8 @@
 #
 # Copyright (c) 2017 Juniper Networks, Inc. All rights reserved.
 #
+from gevent import monkey
+monkey.patch_all()
+
+import grpc.experimental.gevent as grpc_gevent
+grpc_gevent.init_gevent()
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/kube_manager.py new/site-packages/kube_manager/kube_manager.py
--- orig/site-packages/kube_manager/kube_manager.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/kube_manager.py	2018-10-22 16:09:09.000000000 +0200
@@ -229,22 +229,23 @@
     if args.nested_mode == '0':
         # Initialize AMQP handler then close it to be sure remain queue of a
         # precedent run is cleaned
-        rabbitmq_cfg = kube_args.rabbitmq_args(args)
-        try:
-            vnc_amqp = VncAmqpHandle(
-                km_logger._sandesh,
-                km_logger,
-                DBBaseKM,
-                REACTION_MAP,
-                'kube_manager',
-                rabbitmq_cfg
-            )
-            vnc_amqp.establish()
-            vnc_amqp.close()
-        except Exception:  # FIXME: Except clause is too broad
-            pass
-        finally:
-            km_logger.debug("Removed remained AMQP queue")
+        if args.notification_driver == "rabbit":
+            rabbitmq_cfg = kube_args.rabbitmq_args(args)
+            try:
+                vnc_amqp = VncAmqpHandle(
+                    km_logger._sandesh,
+                    km_logger,
+                    DBBaseKM,
+                    REACTION_MAP,
+                    'kube_manager',
+                    rabbitmq_cfg
+                )
+                vnc_amqp.establish()
+                vnc_amqp.close()
+            except Exception:  # FIXME: Except clause is too broad
+                pass
+            finally:
+                km_logger.debug("Removed remained AMQP queue")
 
         # Ensure zookeeper is up and running before starting kube-manager
         _zookeeper_client = ZookeeperClient(client_pfx+"kube-manager",
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/vnc/config_db.py new/site-packages/kube_manager/vnc/config_db.py
--- orig/site-packages/kube_manager/vnc/config_db.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/vnc/config_db.py	2018-10-22 16:09:09.000000000 +0200
@@ -1929,6 +1929,8 @@
         self.annotations = obj.get('annotations', None)
         if self.annotations:
             for kvp in self.annotations['key_value_pair'] or []:
+                if "value" not in kvp:
+                    continue
                 if kvp['key'] == 'tail':
                     self.tail = kvp['value']
                 if kvp['key'] == 'after_tail':
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/vnc/db.py new/site-packages/kube_manager/vnc/db.py
--- orig/site-packages/kube_manager/vnc/db.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/vnc/db.py	2018-10-22 16:09:09.000000000 +0200
@@ -7,18 +7,46 @@
 Kube network manager DB
 """
 
-from cfgm_common.vnc_object_db import VncObjectDBClient
+from cfgm_common.vnc_object_db import VncObjectDBClient, VncObjectEtcdClient
+from cfgm_common.vnc_etcd import etcd_args
 
-class KubeNetworkManagerDB(VncObjectDBClient):
+DRIVER_CASS = 'cassandra'
+DRIVER_ETCD = 'etcd'
 
+
+class KubeNetworkManagerDB(object):
     def __init__(self, args, logger):
         self._db_logger = logger
+        self._db_logger.log("KubeNetworkManagerDB arguments: {}".format(args))
+
+        if not hasattr(args, 'db_driver') or not args.db_driver:
+            msg = str("Contrail API server supports cassandra and etcd "
+                      "backends, but neither of them have been configured.")
+            raise ValueError(msg)
+
+        if args.db_driver == DRIVER_ETCD:
+            self._object_db = self._etcd_driver(args)
+        else:
+            self._object_db = self._cass_driver(args)
+
+    def __getattr__(self, name):
+        return getattr(self._object_db, name)
 
-        cred = None
+    def _cass_driver(self, args):
+        vnc_db = {
+            'server_list': args.cassandra_server_list,
+            'db_prefix': args.cluster_id,
+            'logger': self._db_logger.log,
+            'reset_config': False,
+            'credentials': None,
+        }
         if args.cassandra_user and args.cassandra_password:
-            cred={'username':args.cassandra_user,
-                  'password':args.cassandra_password}
+            vnc_db['credentials'] = {'username': args.cassandra_user,
+                                     'password': args.cassandra_password}
+        self._db_logger.log("VncObjectDBClient arguments: {}".format(vnc_db))
+        return VncObjectDBClient(**vnc_db)
 
-        super(KubeNetworkManagerDB, self).__init__(args.cassandra_server_list,
-            args.cluster_id, None, None, self._db_logger.log,
-            reset_config=False, credential=cred)
+    def _etcd_driver(self, args):
+        vnc_db = etcd_args(args)
+        self._db_logger.log("VncObjectEtcdClient arguments: {}".format(vnc_db))
+        return VncObjectEtcdClient(logger=self._db_logger.log, **vnc_db)
diff -Naur -x '*.pyc' -x '*.orig' -x '*.pyo' orig/site-packages/kube_manager/vnc/vnc_kubernetes.py new/site-packages/kube_manager/vnc/vnc_kubernetes.py
--- orig/site-packages/kube_manager/vnc/vnc_kubernetes.py	2018-10-22 16:55:11.000000000 +0200
+++ new/site-packages/kube_manager/vnc/vnc_kubernetes.py	2018-10-22 16:09:09.000000000 +0200
@@ -19,6 +19,7 @@
 from cfgm_common.exceptions import *
 from cfgm_common.utils import cgitb_hook
 from cfgm_common.vnc_amqp import VncAmqpHandle
+from cfgm_common import vnc_etcd
 from vnc_api.vnc_api import *
 import kube_manager.common.args as kube_args
 from config_db import *
@@ -63,7 +64,6 @@
         self.vnc_kube_config = vnc_kube_config(logger=self.logger,
             vnc_lib=self.vnc_lib, args=self.args, queue=self.q, kube=self.kube)
 
-        #
         # In nested mode, kube-manager connects to contrail components running
         # in underlay via global link local services. TCP flows established on
         # link local services will be torn down by vrouter, if there is no
@@ -72,12 +72,16 @@
         #
         # Note: The way to disable flow timeout is to set timeout to max
         #       possible value.
-        #
         if self.args.nested_mode is '1':
-            for cassandra_server in self.args.cassandra_server_list:
-                cassandra_port = cassandra_server.split(':')[-1]
-                flow_aging_manager.create_flow_aging_timeout_entry(self.vnc_lib,
-                    "tcp", cassandra_port, 2147483647)
+            if self.args.db_driver == db.DRIVER_ETCD:
+                etcd_host, etcd_port = self.args.etcd_server.split(':')
+                flow_aging_manager.create_flow_aging_timeout_entry(
+                    self.vnc_lib, "tcp", etcd_port, 2147483647)
+            else:
+                for cassandra_server in self.args.cassandra_server_list:
+                    cassandra_port = cassandra_server.split(':')[-1]
+                    flow_aging_manager.create_flow_aging_timeout_entry(
+                        self.vnc_lib, "tcp", cassandra_port, 2147483647)
 
             if self.args.rabbit_port:
                 flow_aging_manager.create_flow_aging_timeout_entry(
@@ -103,12 +107,17 @@
         # sync api server db in local cache
         self._sync_km()
 
-        # init rabbit connection
-        rabbitmq_cfg = kube_args.rabbitmq_args(self.args)
-        self.rabbit = VncAmqpHandle(self.logger._sandesh, self.logger, DBBaseKM,
-            REACTION_MAP, 'kube_manager', rabbitmq_cfg)
-        self.rabbit.establish()
-        self.rabbit._db_resync_done.set()
+        # init notifier connection
+        if self.args.notification_driver == "etcd":
+            etcd_cfg = vnc_etcd.etcd_args(self.args)
+            self.notifier = vnc_etcd.VncEtcdWatchHandle(self.logger._sandesh, self.logger, DBBaseKM,
+                                          REACTION_MAP, etcd_cfg)
+        else:
+            rabbitmq_cfg = kube_args.rabbitmq_args(self.args)
+            self.notifier = VncAmqpHandle(self.logger._sandesh, self.logger, DBBaseKM,
+                                          REACTION_MAP, 'kube_manager', rabbitmq_cfg)
+        self.notifier.establish()
+        self.notifier._db_resync_done.set()
 
         # Register label add and delete callbacks with label management entity.
         XLabelCache.register_label_add_callback(VncKubernetes.create_tags)
