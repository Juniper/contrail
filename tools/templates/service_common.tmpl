package services

import (
	"context"
	"encoding/json"
	"fmt"
	"net/http"
	"time"

	"github.com/labstack/echo"
	log "github.com/sirupsen/logrus"

	"github.com/Juniper/contrail/pkg/common"
	"{{ option.PackagePath }}/pkg/models"
	"github.com/Juniper/contrail/pkg/services/baseservices"
)

// Chain setup chain of services.
func Chain(services ...Service) {
	if len(services) < 2 {
		return
	}
	previous := services[0]
	for _, current := range services[1:] {
		previous.SetNext(current)
		previous = current
	}
}

// BaseService is a service that is a link in service chain and has implemented
// all Service methods as noops. Can be embedded in struct to create new service.
type BaseService struct {
	next Service
}

// Next gets next service to call in service chain.
func (service *BaseService) Next() Service {
	return service.next
}

// SetNext sets next service in service chain.
func (service *BaseService) SetNext(next Service) {
	service.next = next
}

// InTransactionDoer executes do function atomically.
type InTransactionDoer interface {
	DoInTransaction(ctx context.Context, do func(context.Context) error) error
}

// RefUpdateToUpdateService is a service that promotes CreateRef and DeleteRef
// methods to Update method by fetching the object and updating reference
// field with fieldmask applied.
type RefUpdateToUpdateService struct {
	BaseService

	ReadService       ReadService
	InTransactionDoer InTransactionDoer
}

//EventProcessor can handle events on generic way.
type EventProcessor interface {
	Process(ctx context.Context, event *Event) (*Event, error)
}

//EventProducerService can dispatch method call for event processor.
type EventProducerService struct {
	BaseService
	Processor EventProcessor
	Timeout   time.Duration
}

//ServiceEventProcessor dispatch event to method call.
type ServiceEventProcessor struct {
	Service Service
}

//Process processes event.
func (p *ServiceEventProcessor) Process(ctx context.Context, event *Event) (*Event, error) {
	return event.Process(ctx, p.Service)
}

// nolint
type ContrailService struct {
	BaseService

	MetadataGetter baseservices.MetadataGetter
	TypeValidator  *models.TypeValidator
}

// RESTSync handles Sync API request.
func (service *ContrailService) RESTSync(c echo.Context) error {
	events := &EventList{}
	if err := c.Bind(events); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("invalid JSON format: %v", err))
	}

	// TODO: Call events.Sort()

	responses, err := events.Process(c.Request().Context(), service)
	if err != nil {
		return common.ToHTTPError(err)
	}
	return c.JSON(http.StatusOK, responses.Events)
}

// RefOperation is enum type for ref-update operation.
type RefOperation string

// RefOperation values.
const (
	RefOperationAdd    RefOperation = "ADD"
	RefOperationDelete RefOperation = "DELETE"
)

// RefUpdate represents ref-update input data.
type RefUpdate struct {
	Operation RefOperation    `json:"operation"`
	Type      string          `json:"type"`
	UUID      string          `json:"uuid"`
	RefType   string          `json:"ref-type"`
	RefUUID   string          `json:"ref-uuid"`
	RefFQName []string        `json:"ref-fq-name"`
	Attr      json.RawMessage `json:"attr"`
}

func (r *RefUpdate) validate() error {
	if r.UUID == "" || r.Type == "" || r.RefType == "" || r.Operation == "" {
		return common.ErrorBadRequestf(
			"uuid/type/ref-type/operation is null: %s, %s, %s, %s",
			r.UUID, r.Type, r.RefType, r.Operation,
		)
	}

	if r.Operation != RefOperationAdd && r.Operation != RefOperationDelete {
		return common.ErrorBadRequestf("operation should be ADD or DELETE, was %s", r.Operation)
	}

	return nil
}

// RESTRefUpdate handles a ref-update request.
func (service *ContrailService) RESTRefUpdate(c echo.Context) error {
	var data RefUpdate
	if err := c.Bind(&data); err != nil {
		log.WithFields(log.Fields{
			"err": err,
		}).Debug("bind failed on ref-update")
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid JSON format")
	}

	if err := data.validate(); err != nil {
		return common.ToHTTPError(err)
	}

	ctx := c.Request().Context()
	if data.RefUUID == "" {
		m, err := service.MetadataGetter.GetMetaData(ctx, "", data.RefFQName)
		if err != nil {
			return common.ToHTTPError(common.ErrorBadRequestf("error resolving ref-uuid using ref-fq-name: %v", err))
		}
		data.RefUUID = m.UUID
	}

	e, err := NewEventFromRefUpdate(&data)
	if err != nil {
		return common.ToHTTPError(common.ErrorBadRequest(err.Error()))
	}
	if _, err = e.Process(ctx, service); err != nil {
		return common.ToHTTPError(err)
	}

	return c.JSON(http.StatusOK, map[string]interface{}{"uuid": data.UUID})
}

// RefRelax represents ref-relax-for-delete input data.
type RefRelax struct {
	UUID    string `json:"uuid"`
	RefUUID string `json:"ref-uuid"`
}

func (r *RefRelax) validate() error {
	if r.UUID == "" || r.RefUUID == "" {
		return common.ErrorBadRequestf(
			"Bad Request: Both uuid and ref-uuid should be specified: %s, %s", r.UUID, r.RefUUID)
	}

	return nil
}

// RESTRefRelaxForDelete handles a ref-relax-for-delete request.
func (service *ContrailService) RESTRefRelaxForDelete(c echo.Context) error {
	var data RefRelax
	if err := c.Bind(&data); err != nil {
		log.WithFields(log.Fields{
			"err": err,
		}).Debug("bind failed on ref-relax-for-delete")
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid JSON format")
	}

	if err := data.validate(); err != nil {
		return common.ToHTTPError(err)
	}

	// TODO (Kamil): implement ref-relax logic

	return c.JSON(http.StatusOK, map[string]interface{}{"uuid": data.UUID})
}

// Application is a part of set-tag input data. TODO: Investigate it
type Application struct {
	IsGlobal bool   `json:"is_global"`
	Value    string `json:"value"`
}

// SetTag represents set-tag input data.
type SetTag struct {
	App     Application `json:"application"`
	ObjUUID string      `json:"obj_uuid"`
	ObjType string      `json:"obj_type"`
}

func (a *Application) validate() bool {
	return a.Value != ""
}

func (t *SetTag) validate() error {
	if t.ObjUUID == "" || t.ObjType == "" {
		return common.ErrorBadRequestf(
			"both obj_uuid and obj_type should be specified but got uuid: '%s' and type: '%s",
			t.ObjUUID, t.ObjType,
		)
	}
	if !t.App.validate() {
		return common.ErrorBadRequestf(
			"set-tag requires specified application value (uuid: %s type: %s)", t.ObjUUID, t.ObjType,
		)
	}
	return nil
}

// RESTSetTag handles set-tag request.
func (service *ContrailService) RESTSetTag(c echo.Context) error {
	var data SetTag

	if err := c.Bind(&data); err != nil {
		log.WithFields(log.Fields{
			"err": err,
		}).Debug("bind failed on set-tag")
		return echo.NewHTTPError(http.StatusBadRequest, "Invalid JSON format")
	}

	if err := data.validate(); err != nil {
		return common.ToHTTPError(err)
	}

	// TODO (Ignacy): implement set-tag logic

	return c.JSON(http.StatusOK, map[string]interface{}{})
}

type routeRegistry interface {
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

//RegisterRESTAPI register REST API service for path.
// nolint
func (service *ContrailService) RegisterRESTAPI(r routeRegistry) {
{% for schema in schemas %}{% if schema.Type != "abstract" and schema.ID %}
	r.POST("{{ schema.Prefix }}{{ schema.PluralPath }}", service.RESTCreate{{ schema.JSONSchema.GoName }})
	r.GET("{{ schema.Prefix }}{{ schema.PluralPath }}", service.RESTList{{ schema.JSONSchema.GoName }})
	r.PUT("{{ schema.Prefix }}{{ schema.Path }}/:id", service.RESTUpdate{{ schema.JSONSchema.GoName }})
	r.GET("{{ schema.Prefix }}{{ schema.Path }}/:id", service.RESTGet{{ schema.JSONSchema.GoName }})
	r.DELETE("{{ schema.Prefix }}{{ schema.Path }}/:id", service.RESTDelete{{ schema.JSONSchema.GoName }})
{% endif%}{% endfor %}
	r.POST("sync", service.RESTSync)
	r.POST("ref-update", service.RESTRefUpdate)
	r.POST("ref-relax-for-delete", service.RESTRefRelaxForDelete)
	r.POST("set-tag", service.RESTSetTag)
	// TODO: Handle gRPC "set-tag" endpoint
}

type registerFunc func(path string, name string)

//RegisterSingularPaths registers singular paths of resources for discovery.
func RegisterSingularPaths (register registerFunc) {
{% for schema in schemas %}{% if schema.Type != "abstract" and schema.ID %}
	register("{{ schema.Prefix }}{{ schema.Path }}", "{{ schema.Path }}")
{% endif %}{% endfor %}
}

// RegisterPluralPaths registers plural paths of resources for discovery.
func RegisterPluralPaths (register registerFunc) {
{% for schema in schemas %}{% if schema.Type != "abstract" and schema.ID %}
	register("{{ schema.Prefix }}{{ schema.PluralPath }}", "{{ schema.Path }}")
{% endif %}{% endfor %}
}
