{% autoescape off %}
package models

import (
    "encoding/json"
    "fmt"
    "strings"

    "github.com/pkg/errors"

    "github.com/Juniper/contrail/pkg/common"
)

{% for t in types %}

{% set type = t.type %}
{% set name = t.name %}
{% set typename = t.typename %}
{% set references = t.references %}
{% set parent = t.parents %}
{% set children = t.children %}

const Kind{{ name }} = "{{ typename }}"

{% if type.Type == "object" %}

const (
    {% for property in type.OrderedProperties %}{{ name }}Field{{ property.GoName }} = "{{ property.ID }}"
    {% endfor %}
    {% for linkTo, reference in references %}{{ name }}Field{{ reference.GoName }}Refs = "{{ linkTo }}_refs"
    {% endfor %}
)

// Make{{ name }} makes {{ name }}
// nolint
func Make{{ name }}() *{{name}}{
    return &{{name}}{
    //TODO(nati): Apply default
    {% for property in type.OrderedProperties %}{% if property.GoType == "string" %}{{ property.GoName }}: "",
        {% elif property.GoType == "[]string" %}{{ property.GoName }}: []string{},
        {% elif property.GoType == "[]interface" %}{{ property.GoName }}: []interface{},
        {% elif property.GoType == "map[string]string" %}{{ property.GoName }}: map[string]string{},
        {% elif property.GoType == "map[string]interface{}" %}{{ property.GoName }}: map[string]interface{}{},
        {% elif property.GoType == "bool" %}{{ property.GoName }}: false,
        {% elif property.GoType == "int64" %}{{ property.GoName }}: 0,
        {% elif property.GoType == "float" %}{{ property.GoName }}: 0,
        {% elif property.Type == "array"%}
            {% if property.Items.Type == "string" %}
                {{ property.GoName }}: []string{},
            {% elif property.Items.Type == "integer"%}
                {{ property.GoName }}: []int64{},
            {% elif property.Items.GoType %}
                {{ property.GoName }}:  Make{{ property.Items.GoType }}Slice(),
            {% endif %}
        {% else %}{{ property.GoName }}: Make{{ property.GoType }}(),
        {% endif %}{% endfor %}

        {% for linkTo, reference in references %}{% if reference.Presence == "required" or reference.Presence == "true" %}
            {{ reference.GoName }}Refs: []*{{ name }}{{ reference.GoName }}Ref{},{% endif %}{% endfor %}
    }
}

// InterfaceTo{{ name }} converts interface to {{ name }}
// nolint
func InterfaceTo{{ name }}(i interface{}) *{{name}}{
    p, ok := i.(*{{name}})
    if ok {
        return p
    }
    o, ok := i.({{name}})
    if ok {
        return &o
    }
    m, ok := i.(map[string]interface{})
    _ = m
    if !ok {
        return nil
    }
    return &{{name}}{
    //TODO(nati): Apply default
    {% for property in type.OrderedProperties %}{% if property.GoType == "string" %}{{ property.GoName }}: common.InterfaceToString(m["{{ property.ID }}"]),
        {% elif property.GoType == "[]string" %}{{ property.GoName }}: common.InterfaceToStringList(m["{{ property.ID }}"]),
        {% elif property.GoType == "[]interface" %}{{ property.GoName }}: common.InterfaceToStringList(m["{{ property.ID }}"]),
        {% elif property.GoType == "map[string]string" %}{{ property.GoName }}: common.InterfaceToStringMap(m["{{ property.ID }}"]),
        {% elif property.GoType == "map[string]interface{}" %}{{ property.GoName }}: common.InterfaceToInterfaceMap(m["{{ property.ID }}"]),
        {% elif property.GoType == "bool" %}{{ property.GoName }}: common.InterfaceToBool(m["{{ property.ID }}"]),
        {% elif property.GoType == "int64" %}{{ property.GoName }}: common.InterfaceToInt64(m["{{ property.ID }}"]),
        {% elif property.GoType == "float" %}{{ property.GoName }}: common.InterfaceToFloat(m["{{ property.ID }}"]),,
        {% elif property.Type == "array"%}
            {% if property.Items.Type == "string" %}
                {{ property.GoName }}: common.InterfaceToStringList(m["{{ property.ID }}"]),
            {% elif property.Items.Type == "integer"%}
                {{ property.GoName }}: common.InterfaceToInt64List(m["{{ property.ID }}"]),
            {% elif property.Items.GoType %}
                {{ property.GoName }}:  InterfaceTo{{ property.Items.GoType }}Slice(m["{{ property.ID }}"]),
            {% endif %}
        {% else %}{{ property.GoName }}: InterfaceTo{{ property.GoType }}(m["{{ property.ID }}"]),
        {% endif %}{% endfor %}
        {% for linkTo, reference in references %}
            {{ reference.GoName }}Refs : InterfaceTo{{ type.GoName }}{{ reference.GoName }}Refs(m["{{ linkTo }}_refs"]),
        {% endfor %}
    }
}

// ToMap makes map representation of a resource.
// nolint
func (m *{{ name }}) ToMap() map[string]interface{} {
    if m == nil {
        return nil
    }
    return map[string]interface{}{
    {% for property in type.OrderedProperties %}
        {% if property.GoType == "string" || property.GoType == "[]string" || property.GoType == "[]interface" || property.GoType == "map[string]interface{}" || property.GoType == "map[string]string" || property.GoType == "bool" || property.GoType == "int64" || property.GoType == "float" || property.Type == "array" %} "{{ property.ID }}": m.{{ property.GoName}},
        {% else %}"{{ property.ID }}": m.{{ property.GoName}}.ToMap(),
    {% endif %}{% endfor %}
    {% for linkTo, reference in references %}
        "{{ linkTo }}_refs" : {{ name }}{{ reference.GoName }}RefsToMap(m.{{ reference.GoName }}Refs),
    {% endfor %}
    }
}


// Kind returns kind of an resource.
func (m *{{ name }}) Kind() string {
    return Kind{{ name }}
}

func (m *{{ name }}) Depends() []string {
    var depends []string
    if m == nil {
        return nil
    }
    {% for property in type.OrderedProperties %}
    {% if property == "parent_uuid" %}
    depends = append(depends, m.GetParentUUID())
    {% endif %}
    {% endfor %}
    {% for linkTo, reference in references %}
    for _, ref := range m.{{ reference.GoName }}Refs {
        depends = append(depends, ref.GetUUID())
    }
    {% endfor %}
    return depends
}

{% if typename %}
func (m *{{ name }}) ApplyPropCollectionUpdate(u *PropCollectionUpdate) (map[string]interface{}, error) {
    switch (u.Field) { {% for property in type.OrderedProperties %}{% if property.CollectionType %}
{% set listType = property.OrderedProperties | first %}{% set itemType = listType.Items.GoType %}
{% if property.CollectionType == "list" %}
    case {{ name }}Field{{ property.GoName }}:
        pos, err := u.positionForList()
        if err != nil {
            return nil, err
        }
        switch strings.ToLower(u.Operation) {
        case PropCollectionUpdateOperationAdd:
            var value {{ itemType }}
            err := json.Unmarshal(u.Value, &value)
            if err != nil {
                return nil, errors.Wrap(err, "malformed value field")
            }
            m.{{property.GoName}}.AddInList({% if itemType != "string" %}&{% endif %}value)
        case PropCollectionUpdateOperationModify:
            var value {{ itemType }}
            err := json.Unmarshal(u.Value, &value)
            if err != nil {
                return nil, errors.Wrap(err, "malformed value field")
            }
            m.{{property.GoName}}.ModifyInList({% if itemType != "string" %}&{% endif %}value, pos)
        case PropCollectionUpdateOperationDelete:
            m.{{property.GoName}}.DeleteInList(pos)
        }
        return map[string]interface{}{u.Field: m.{{ property.GoName }}}, nil
{% elif property.CollectionType == "map" %}
    case {{ name }}Field{{ property.GoName }}:
        err := u.validateForMap()
        if err != nil {
            return nil, err
        }
        switch strings.ToLower(u.Operation) {
        case PropCollectionUpdateOperationSet:
            var value {{ itemType }}
            err := json.Unmarshal(u.Value, &value)
            if err != nil {
                return nil, errors.Wrap(err, "malformed value field")
            }
            m.{{property.GoName}}.SetInMap({% if itemType != "string" %}&{% endif %}value)
        case PropCollectionUpdateOperationDelete:
            m.{{property.GoName}}.DeleteInMap(u.Position)
        }
        return map[string]interface{}{u.Field: m.{{ property.GoName }}}, nil
{% endif %}{% endif %}{% endfor %}
    default:
        return nil, errors.Errorf("type {{ typename }} has no prop collection field named: %s", u.Field)
    }
}
{% endif %}

{% if t.type.CollectionType == "map" %}
{% set kvsType = type.OrderedProperties | first %}{% set keyType = type.KeyProperty.GoName %}
func (m *{{name}}) SetInMap(value *{{kvsType.Items.GoType}}) {
    for i, kv := range m.{{ kvsType.GoName }} {
        if kv.{{ keyType }} == value.{{ keyType }} {
            // key found - replace
            m.{{ kvsType.GoName }}[i] = value
            return
        }
    }
    // key not found - append
    m.{{ kvsType.GoName }} = append(m.{{ kvsType.GoName }}, value)
}

func (m *{{name}}) DeleteInMap(position string) {
    kvs := m.{{ kvsType.GoName }}
    for i, kv := range kvs {
        if fmt.Sprint(kv.{{ keyType }}) == position {
            // key found - delete
            m.{{ kvsType.GoName }} = append(kvs[:i], kvs[i+1:]...)
            return
        }
    }
}{% elif type.CollectionType == "list" %}
{% set listType = type.OrderedProperties | first %}{% set itemType = listType.Items.GoType %}
func (m *{{name}}) AddInList(value {% if itemType == "string"%}{{ itemType }}{% else %}*{{ itemType }}{% endif %}) {
    m.{{ listType.GoName }} = append(m.{{ listType.GoName }}, value)
}

func (m *{{name}}) ModifyInList(value {% if itemType == "string"%}{{ itemType }}{% else %}*{{ itemType }}{% endif %}, position int) {
    list := m.{{ listType.GoName }}
    if position >= len(list) {
        return
    }
    for i := range list {
        if i == position {
            // key found - replace
            m.{{ listType.GoName }}[i] = value
            return
        }
    }
}

func (m *{{name}}) DeleteInList(position int) {
    list := m.{{ listType.GoName }}
    if position >= len(list) {
        return
    }
    m.{{ listType.GoName }} = append(list[:position], list[position+1:]...)
}{% endif %}

{% for linkTo, reference in references %}
func {{ name }}{{ reference.GoName }}RefsToMap(l []*{{ name }}{{ reference.GoName }}Ref) []interface{} {
    var result []interface{}
    for _, i := range l {
        result = append(result, i.ToMap())
    }
    return result
}

func (r *{{ name }}{{ reference.GoName }}Ref) ToMap() map[string]interface{} {
    return map[string]interface{}{
        "uuid": r.UUID,
        "to": r.To,
        {% if reference.RefType %}
        "attr": r.Attr.ToMap(),
        {% endif %}
    }
}

func InterfaceTo{{ name }}{{ reference.GoName }}Refs(i interface{}) []*{{ name }}{{ reference.GoName }}Ref {
    list, ok := i.([]interface{})
    if !ok {
        return nil
    }
    result := []*{{ type.GoName  }}{{ reference.GoName }}Ref{}
    for _, item := range list {
        m, ok := item.(map[string]interface{})
        _ = m
        if !ok {
            return nil
        }
        result = append(result, &{{ type.GoName  }}{{ reference.GoName }}Ref{
            UUID: common.InterfaceToString(m["uuid"]),
            To: common.InterfaceToStringList(m["to"]),
            {% if reference.RefType %}
            Attr: InterfaceTo{{ reference.RefType }}(m["attr"]),
            {% endif %}
        })
    }

    return result
}

func (m *{{ name }}) Add{{ reference.GoName }}Ref(toAdd *{{ type.GoName }}{{ reference.GoName }}Ref) {
    if toAdd == nil {
        return
    }
    updated := false
    refs := m.{{ reference.GoName }}Refs
    for i, ref := range refs {
        if ref.UUID == toAdd.GetUUID() {
            refs[i] = toAdd
            updated = true
        }
    }
    if !updated {
        refs = append(refs, toAdd)
    }
    m.{{ reference.GoName }}Refs = refs
}

func (m *{{ name }}) Remove{{ reference.GoName }}Ref(toRemove *{{ type.GoName }}{{ reference.GoName }}Ref) {
    if toRemove == nil {
        return
    }
    refs := m.{{ reference.GoName }}Refs
    result := refs[:0]
    for _, ref := range refs {
        if ref.UUID != toRemove.GetUUID() {
            result = append(result, ref)
        }
    }
    m.{{ reference.GoName }}Refs = result
}{% endfor %}

// Make{{ name }}Slice() makes a slice of {{ name }}
// nolint
func Make{{ name }}Slice() []{% if type.Properties %}*{% endif %}{{ name }} {
    return []{% if type.Properties %}*{% endif %}{{ name }}{}
}

// InterfaceTo{{ name }}Slice() makes a slice of {{ name }}
// nolint
func InterfaceTo{{ name }}Slice(i interface{}) []{% if type.Properties %}*{% endif %}{{ name }} {
    list := common.InterfaceToInterfaceList(i)
    if list == nil {
        return nil
    }
    result := []{% if type.Properties %}*{% endif %}{{ name }}{}
    for _, item := range list {
        result = append(result, InterfaceTo{{ name }}(item) )
    }
    return result
}

{% endif %}

{% endfor %}
{% endautoescape %}
