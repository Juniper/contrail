// Code generated by contrailschema tool from template list_response_encoding.tmpl; DO NOT EDIT.

package services

import (
	"encoding/json"

	"github.com/pkg/errors"

	"github.com/Juniper/contrail/extension/pkg/models"
	"github.com/Juniper/contrail/pkg/errutil"
)

func (r ListSampleResponse) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.toMap())
}

func (r *ListSampleResponse) UnmarshalJSON(data []byte) error {
	return r.unmarshalWith(func(dest interface{}) error {
		return json.Unmarshal(data, dest)
	})
}

func (r ListSampleResponse) MarshalYAML() (interface{}, error) {
	return r.toMap(), nil
}

func (r *ListSampleResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return r.unmarshalWith(unmarshal)
}

func (r ListSampleResponse) toMap() map[string]interface{} {
	if r.Samples == nil {
		return map[string]interface{}{
			"samples": map[string]interface{}{
				"count": r.SampleCount,
			},
		}
	}

	return map[string]interface{}{
		"samples": r.Samples,
	}

}

func (r *ListSampleResponse) unmarshalWith(unmarshal func(interface{}) error) error {
	var listResponse struct {
		Resources []*models.Sample `json:"samples" yaml:"samples"`
	}
	err := unmarshal(&listResponse)
	if err == nil {
		list := listResponse.Resources
		*r = ListSampleResponse{
			Samples:     list,
			SampleCount: int64(len(list)),
		}
		return nil
	}

	// err != nil is not necessarily an error: the response could be a count response
	errs := errutil.MultiError{err}
	var countResponse struct {
		Resources struct {
			Count int64 `json:"count" yaml="count"`
		} `json:"samples" yaml:"samples"`
	}
	if err = unmarshal(&countResponse); err != nil {
		errs = append(errs, err)
		return errors.Wrap(errs, "failed to unmarshal ListSampleResponse")
	}

	*r = ListSampleResponse{
		Samples:     nil,
		SampleCount: countResponse.Resources.Count,
	}
	return nil
}

func (r ListTagResponse) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.toMap())
}

func (r *ListTagResponse) UnmarshalJSON(data []byte) error {
	return r.unmarshalWith(func(dest interface{}) error {
		return json.Unmarshal(data, dest)
	})
}

func (r ListTagResponse) MarshalYAML() (interface{}, error) {
	return r.toMap(), nil
}

func (r *ListTagResponse) UnmarshalYAML(unmarshal func(interface{}) error) error {
	return r.unmarshalWith(unmarshal)
}

func (r ListTagResponse) toMap() map[string]interface{} {
	if r.Tags == nil {
		return map[string]interface{}{
			"tags": map[string]interface{}{
				"count": r.TagCount,
			},
		}
	}

	return map[string]interface{}{
		"tags": r.Tags,
	}

}

func (r *ListTagResponse) unmarshalWith(unmarshal func(interface{}) error) error {
	var listResponse struct {
		Resources []*models.Tag `json:"tags" yaml:"tags"`
	}
	err := unmarshal(&listResponse)
	if err == nil {
		list := listResponse.Resources
		*r = ListTagResponse{
			Tags:     list,
			TagCount: int64(len(list)),
		}
		return nil
	}

	// err != nil is not necessarily an error: the response could be a count response
	errs := errutil.MultiError{err}
	var countResponse struct {
		Resources struct {
			Count int64 `json:"count" yaml="count"`
		} `json:"tags" yaml:"tags"`
	}
	if err = unmarshal(&countResponse); err != nil {
		errs = append(errs, err)
		return errors.Wrap(errs, "failed to unmarshal ListTagResponse")
	}

	*r = ListTagResponse{
		Tags:     nil,
		TagCount: countResponse.Resources.Count,
	}
	return nil
}
