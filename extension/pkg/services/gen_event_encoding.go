// Code generated by contrailschema tool from template event_encoding.tmpl; DO NOT EDIT.

package services

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/gogo/protobuf/types"
	"github.com/pkg/errors"

	"github.com/Juniper/contrail/extension/pkg/models"
	"github.com/Juniper/contrail/pkg/fileutil"
	"github.com/Juniper/contrail/pkg/format"
	"github.com/Juniper/contrail/pkg/models/basemodels"
)

const (
	//OperationCreate for create operation.
	OperationCreate = "CREATE"
	//OperationUpdate for update operation.
	OperationUpdate = "UPDATE"
	//OperationDelete for delete operation.
	OperationDelete = "DELETE"
)

// EventOption contains options for Event.
type EventOption struct {
	UUID      string
	Operation string
	Kind      string
	Data      map[string]interface{}
	FieldMask *types.FieldMask
}

// HasResource defines methods that might be implemented by Event.
type HasResource interface {
	GetResource() basemodels.Object
	Operation() string
	ExtractRefsEventFromEvent() (*Event, error)
}

// CanProcessService is interface for process service.
type CanProcessService interface {
	Process(ctx context.Context, service Service) (*Event, error)
}

// EventList has multiple rest requests.
type EventList struct {
	Events []*Event `json:"resources" yaml:"resources"`
}

type state int

const (
	notVisited state = iota
	visited
	temporaryVisited
)

//reorder request using Tarjan's algorithm
func visitResource(uuid string, sorted []*Event,
	eventMap map[string]*Event, stateGraph map[string]state,
) (sortedList []*Event, err error) {
	if stateGraph[uuid] == temporaryVisited {
		return nil, errors.New("dependency loop found in sync request")
	}
	if stateGraph[uuid] == visited {
		return sorted, nil
	}
	stateGraph[uuid] = temporaryVisited
	event, found := eventMap[uuid]
	if !found {
		stateGraph[uuid] = visited
		return sorted, nil
	}
	parentUUID := event.GetResource().GetParentUUID()

	sorted, err = visitResource(parentUUID, sorted, eventMap, stateGraph)
	if err != nil {
		return nil, err
	}

	stateGraph[uuid] = visited
	sorted = append(sorted, event)
	return sorted, nil
}

// Sort sorts Events by parent-child dependency using Tarjan algorithm.
// It doesn't verify reference cycles.
func (e *EventList) Sort() (err error) {
	var sorted []*Event
	stateGraph := map[string]state{}
	eventMap := map[string]*Event{}
	for _, event := range e.Events {
		uuid := event.GetResource().GetUUID()
		stateGraph[uuid] = notVisited
		eventMap[uuid] = event
	}
	foundNotVisited := true
	for foundNotVisited {
		foundNotVisited = false
		for _, event := range e.Events {
			uuid := event.GetResource().GetUUID()
			state := stateGraph[uuid]
			if state == notVisited {
				sorted, err = visitResource(uuid, sorted, eventMap, stateGraph)
				if err != nil {
					return err
				}
				foundNotVisited = true
				break
			}
		}
	}
	e.Events = sorted
	return nil
}

// Process dispatches resource event to call corresponding service functions.
func (e *Event) Process(ctx context.Context, service Service) (*Event, error) {
	return e.Request.(CanProcessService).Process(ctx, service)
}

// Process process list of events.
func (e *EventList) Process(ctx context.Context, service Service) (*EventList, error) {
	var responses []*Event
	for _, event := range e.Events {
		response, err := event.Process(ctx, service)
		if err != nil {
			return nil, err
		}
		responses = append(responses, response)
	}
	return &EventList{
		Events: responses,
	}, nil
}

// GetResource returns event on resource.
func (e *Event) GetResource() basemodels.Object {
	if e == nil {
		return nil
	}
	resourceEvent, ok := e.Request.(HasResource)
	if !ok {
		return nil
	}
	return resourceEvent.GetResource()
}

// Operation returns operation type.
func (e *Event) Operation() string {
	if e == nil {
		return ""
	}
	resourceEvent, ok := e.Request.(HasResource)
	if !ok {
		return ""
	}
	return resourceEvent.Operation()
}

//GetResource returns resource.
func (e *Event_CreateSampleRequest) GetResource() basemodels.Object {
	return e.CreateSampleRequest.GetSample()
}

//GetResource returns resource.
func (e *Event_UpdateSampleRequest) GetResource() basemodels.Object {
	return e.UpdateSampleRequest.GetSample()
}

//GetResource returns resource.
func (e *Event_DeleteSampleRequest) GetResource() basemodels.Object {
	return &models.Sample{
		UUID: e.DeleteSampleRequest.ID,
	}
}

//Operation returns event type.
func (e *Event_CreateSampleRequest) Operation() string {
	return OperationCreate
}

//Operation returns event type.
func (e *Event_UpdateSampleRequest) Operation() string {
	return OperationUpdate
}

//Operation returns event type.
func (e *Event_DeleteSampleRequest) Operation() string {
	return OperationDelete
}

//GetResource returns resource.
func (e *Event_CreateTagRequest) GetResource() basemodels.Object {
	return e.CreateTagRequest.GetTag()
}

//GetResource returns resource.
func (e *Event_UpdateTagRequest) GetResource() basemodels.Object {
	return e.UpdateTagRequest.GetTag()
}

//GetResource returns resource.
func (e *Event_DeleteTagRequest) GetResource() basemodels.Object {
	return &models.Tag{
		UUID: e.DeleteTagRequest.ID,
	}
}

//Operation returns event type.
func (e *Event_CreateTagRequest) Operation() string {
	return OperationCreate
}

//Operation returns event type.
func (e *Event_UpdateTagRequest) Operation() string {
	return OperationUpdate
}

//Operation returns event type.
func (e *Event_DeleteTagRequest) Operation() string {
	return OperationDelete
}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_CreateSampleRequest) ExtractRefsEventFromEvent() (*Event, error) {

	updateRequest := UpdateSampleRequest{
		Sample: &models.Sample{},
	}
	createRequest := e.CreateSampleRequest
	*(updateRequest.Sample) = *(createRequest.Sample)

	createRequest.Sample.TagRefs = createRequest.Sample.TagRefs[:0]

	optForUpdate := &EventOption{
		UUID:      createRequest.Sample.GetUUID(),
		Operation: OperationUpdate,
		Kind:      "sample",
		Data:      updateRequest.Sample.ToMap(),
	}
	updateEvent, err := NewEvent(optForUpdate)
	if err != nil {
		return nil, err
	}
	e.CreateSampleRequest = createRequest
	return updateEvent, nil

}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_UpdateSampleRequest) ExtractRefsEventFromEvent() (*Event, error) {
	return nil, nil
}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_DeleteSampleRequest) ExtractRefsEventFromEvent() (*Event, error) {
	// TODO: Extract event for removing refs from resource before deleting it
	return nil, nil
}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_CreateTagRequest) ExtractRefsEventFromEvent() (*Event, error) {

	updateRequest := UpdateTagRequest{
		Tag: &models.Tag{},
	}
	createRequest := e.CreateTagRequest
	*(updateRequest.Tag) = *(createRequest.Tag)

	createRequest.Tag.TagRefs = createRequest.Tag.TagRefs[:0]

	optForUpdate := &EventOption{
		UUID:      createRequest.Tag.GetUUID(),
		Operation: OperationUpdate,
		Kind:      "tag",
		Data:      updateRequest.Tag.ToMap(),
	}
	updateEvent, err := NewEvent(optForUpdate)
	if err != nil {
		return nil, err
	}
	e.CreateTagRequest = createRequest
	return updateEvent, nil

}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_UpdateTagRequest) ExtractRefsEventFromEvent() (*Event, error) {
	return nil, nil
}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event_DeleteTagRequest) ExtractRefsEventFromEvent() (*Event, error) {
	// TODO: Extract event for removing refs from resource before deleting it
	return nil, nil
}

// ExtractRefsEventFromEvent extracts references and puts them into a newly created event.
func (e *Event) ExtractRefsEventFromEvent() (*Event, error) {
	if e.Request.(HasResource) == nil {
		return nil, errors.Errorf("Cannot extract refs from event %v.", e.ToMap())
	}
	refEvent, err := e.Request.(HasResource).ExtractRefsEventFromEvent()
	if err != nil {
		return nil, errors.Wrap(err, "extracting references update from event failed")
	}
	return refEvent, nil
}

//NewEvent makes event from interface
func NewEvent(option *EventOption) (*Event, error) {
	e := &Event{}
	kind := strings.Replace(option.Kind, "-", "_", -1)
	data := option.Data
	uuid := option.UUID
	operation := option.Operation
	if operation == "" {
		operation = OperationCreate
	}
	fm := option.FieldMask
	switch kind {

	case "sample":
		switch operation {
		case OperationCreate:
			obj := models.InterfaceToSample(data)
			if uuid != "" {
				obj.UUID = uuid
			}
			e.Request = &Event_CreateSampleRequest{
				CreateSampleRequest: &CreateSampleRequest{
					Sample: obj,
				}}
		case OperationUpdate:
			obj := models.InterfaceToSample(data)
			if uuid != "" {
				obj.UUID = uuid
			}
			if fm == nil {
				f := basemodels.MapToFieldMask(data)
				fm = &f
			}
			e.Request = &Event_UpdateSampleRequest{
				UpdateSampleRequest: &UpdateSampleRequest{
					Sample:    obj,
					FieldMask: *fm,
				}}
		case OperationDelete:
			e.Request = &Event_DeleteSampleRequest{
				DeleteSampleRequest: &DeleteSampleRequest{
					ID: uuid,
				}}
		}
	case "tag":
		switch operation {
		case OperationCreate:
			obj := models.InterfaceToTag(data)
			if uuid != "" {
				obj.UUID = uuid
			}
			e.Request = &Event_CreateTagRequest{
				CreateTagRequest: &CreateTagRequest{
					Tag: obj,
				}}
		case OperationUpdate:
			obj := models.InterfaceToTag(data)
			if uuid != "" {
				obj.UUID = uuid
			}
			if fm == nil {
				f := basemodels.MapToFieldMask(data)
				fm = &f
			}
			e.Request = &Event_UpdateTagRequest{
				UpdateTagRequest: &UpdateTagRequest{
					Tag:       obj,
					FieldMask: *fm,
				}}
		case OperationDelete:
			e.Request = &Event_DeleteTagRequest{
				DeleteTagRequest: &DeleteTagRequest{
					ID: uuid,
				}}
		}
	default:
		return nil, errors.Errorf("type %s does not exist", kind)
	}
	return e, nil
}

// NewEventFromRefUpdate creates ref create or delete event from RefUpdate object.
/* TODO This might be refactored to not accept RefUpdate type
instead it may accept only UUIDs and data that is passed to resolveReferenceTable
*/
func NewEventFromRefUpdate(refUpdate *RefUpdate) (*Event, error) {
	e := &Event{}
	kind := fmt.Sprintf("%s-%s", refUpdate.Type, refUpdate.RefType)
	operation := refUpdate.Operation
	if operation == "" {
		operation = RefOperationAdd
	}
	switch kind {

	case "sample-tag":
		switch operation {
		case RefOperationAdd:
			request := &Event_CreateSampleTagRefRequest{
				CreateSampleTagRefRequest: &CreateSampleTagRefRequest{
					ID: refUpdate.UUID,
					SampleTagRef: &models.SampleTagRef{
						UUID: refUpdate.RefUUID,
					},
				},
			}

			e.Request = request
		case RefOperationDelete:
			e.Request = &Event_DeleteSampleTagRefRequest{
				DeleteSampleTagRefRequest: &DeleteSampleTagRefRequest{
					ID: refUpdate.UUID,
					SampleTagRef: &models.SampleTagRef{
						UUID: refUpdate.RefUUID,
					},
				},
			}
		}

	case "tag-tag":
		switch operation {
		case RefOperationAdd:
			request := &Event_CreateTagTagRefRequest{
				CreateTagTagRefRequest: &CreateTagTagRefRequest{
					ID: refUpdate.UUID,
					TagTagRef: &models.TagTagRef{
						UUID: refUpdate.RefUUID,
					},
				},
			}

			e.Request = request
		case RefOperationDelete:
			e.Request = &Event_DeleteTagTagRefRequest{
				DeleteTagTagRefRequest: &DeleteTagTagRefRequest{
					ID: refUpdate.UUID,
					TagTagRef: &models.TagTagRef{
						UUID: refUpdate.RefUUID,
					},
				},
			}
		}
	default:
		return nil, errors.Errorf("ref from type %s to type %s does not exist", refUpdate.Type, refUpdate.RefType)
	}
	return e, nil
}

//UnmarshalJSON unmarshal event.
func (e *Event) UnmarshalJSON(data []byte) error {
	raw := make(map[string]json.RawMessage)
	err := json.Unmarshal(data, &raw)
	if err != nil {
		return err
	}
	t, ok := raw["kind"]
	if !ok {
		return nil
	}
	var kind string
	err = json.Unmarshal(t, &kind)
	if err != nil {
		return err
	}
	d, ok := raw["data"]
	if !ok {
		return nil
	}
	o := raw["operation"]
	var operation string
	json.Unmarshal(o, &operation)
	if operation == "" {
		operation = OperationCreate
	}
	switch kind {

	case "sample":
		switch operation {
		case OperationCreate:
			var m models.Sample
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_CreateSampleRequest{
				CreateSampleRequest: &CreateSampleRequest{
					Sample: &m,
				},
			}
		case OperationUpdate:
			m := map[string]interface{}{}
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_UpdateSampleRequest{
				UpdateSampleRequest: &UpdateSampleRequest{
					Sample:    models.InterfaceToSample(m),
					FieldMask: basemodels.MapToFieldMask(m),
				},
			}
		case OperationDelete:
			m := map[string]interface{}{}
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_DeleteSampleRequest{
				DeleteSampleRequest: &DeleteSampleRequest{
					ID: m["uuid"].(string),
				},
			}
		}

	case "tag":
		switch operation {
		case OperationCreate:
			var m models.Tag
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_CreateTagRequest{
				CreateTagRequest: &CreateTagRequest{
					Tag: &m,
				},
			}
		case OperationUpdate:
			m := map[string]interface{}{}
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_UpdateTagRequest{
				UpdateTagRequest: &UpdateTagRequest{
					Tag:       models.InterfaceToTag(m),
					FieldMask: basemodels.MapToFieldMask(m),
				},
			}
		case OperationDelete:
			m := map[string]interface{}{}
			err = json.Unmarshal(d, &m)
			if err != nil {
				return err
			}
			e.Request = &Event_DeleteTagRequest{
				DeleteTagRequest: &DeleteTagRequest{
					ID: m["uuid"].(string),
				},
			}
		}

	}
	return nil
}

//ToMap translate event to map.
func (e *Event) ToMap() map[string]interface{} {
	m := map[string]interface{}{}
	switch t := e.Request.(type) {

	case *Event_CreateSampleRequest:
		m["kind"] = "sample"
		m["operation"] = OperationCreate
		m["data"] = t.CreateSampleRequest.Sample
	case *Event_UpdateSampleRequest:
		m["kind"] = "sample"
		m["operation"] = OperationUpdate
		m["data"] = t.UpdateSampleRequest.Sample
	case *Event_DeleteSampleRequest:
		m["kind"] = "sample"
		m["operation"] = OperationDelete
		m["data"] = map[string]interface{}{
			"uuid": t.DeleteSampleRequest.ID,
		}

	case *Event_CreateTagRequest:
		m["kind"] = "tag"
		m["operation"] = OperationCreate
		m["data"] = t.CreateTagRequest.Tag
	case *Event_UpdateTagRequest:
		m["kind"] = "tag"
		m["operation"] = OperationUpdate
		m["data"] = t.UpdateTagRequest.Tag
	case *Event_DeleteTagRequest:
		m["kind"] = "tag"
		m["operation"] = OperationDelete
		m["data"] = map[string]interface{}{
			"uuid": t.DeleteTagRequest.ID,
		}

	}
	return m
}

//MarshalJSON marshal event.
func (e *Event) MarshalJSON() ([]byte, error) {
	return json.Marshal(e.ToMap())
}

//MarshalYAML marshal event to yaml.
func (e *Event) MarshalYAML() (interface{}, error) {
	return e.ToMap(), nil
}

//UnmarshalYAML unmarshal event.
func (e *Event) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var r interface{}
	err := unmarshal(&r)
	if err != nil {
		return err
	}
	raw := r.(map[interface{}]interface{})
	kind := raw["kind"]
	data := fileutil.YAMLtoJSONCompat(raw["data"])
	operation := format.InterfaceToString(raw["operation"])
	if operation == "" {
		operation = OperationCreate
	}
	switch kind {

	case "sample":
		switch operation {
		case OperationCreate:
			m := models.InterfaceToSample(data)
			if err != nil {
				return err
			}
			e.Request = &Event_CreateSampleRequest{
				CreateSampleRequest: &CreateSampleRequest{
					Sample: m,
				},
			}
		case OperationUpdate:
			e.Request = &Event_UpdateSampleRequest{
				UpdateSampleRequest: &UpdateSampleRequest{
					Sample:    models.InterfaceToSample(data),
					FieldMask: basemodels.MapToFieldMask(data.(map[string]interface{})),
				},
			}
		case OperationDelete:
			m := data.(map[string]interface{})
			e.Request = &Event_DeleteSampleRequest{
				DeleteSampleRequest: &DeleteSampleRequest{
					ID: m["uuid"].(string),
				},
			}
		}

	case "tag":
		switch operation {
		case OperationCreate:
			m := models.InterfaceToTag(data)
			if err != nil {
				return err
			}
			e.Request = &Event_CreateTagRequest{
				CreateTagRequest: &CreateTagRequest{
					Tag: m,
				},
			}
		case OperationUpdate:
			e.Request = &Event_UpdateTagRequest{
				UpdateTagRequest: &UpdateTagRequest{
					Tag:       models.InterfaceToTag(data),
					FieldMask: basemodels.MapToFieldMask(data.(map[string]interface{})),
				},
			}
		case OperationDelete:
			m := data.(map[string]interface{})
			e.Request = &Event_DeleteTagRequest{
				DeleteTagRequest: &DeleteTagRequest{
					ID: m["uuid"].(string),
				},
			}
		}

	}
	return nil
}
