// Code generated by contrailschema tool from template model.tmpl; DO NOT EDIT.

package models

import (
	"encoding/json"
	"fmt"
	"math/rand"
	"strconv"
	"strings"
	"time"

	"github.com/pkg/errors"

	"github.com/Juniper/contrail/pkg/format"
	"github.com/Juniper/contrail/pkg/models/basemodels"
)

//This is needed to prevent an import error.
var _ = basemodels.Metadata{}

//Version is a model version.
const Version = "1.0"

// NewIDPerms creates new UUIdType instance
func NewIDPerms(uuid string) *IdPermsType {
	return &IdPermsType{
		UUID:   NewUUIDType(uuid),
		Enable: true,
	}
}

// NewUUIDType creates new UUIdType instance from provided uuid.
func NewUUIDType(uuid string) *UuidType {
	uuid = strings.Replace(uuid, "-", "", 4)
	uuidHigh, err1 := strconv.ParseUint(uuid[:len(uuid)/2], 16, 64)
	uuidLow, err2 := strconv.ParseUint(uuid[len(uuid)/2:], 16, 64)

	if len(uuid) != 32 || err1 != nil || err2 != nil {
		random := rand.New(rand.NewSource(time.Now().UnixNano()))
		uuidHigh = random.Uint64()
		uuidLow = random.Uint64()
	}

	return &UuidType{
		UUIDMslong: uuidHigh,
		UUIDLslong: uuidLow,
	}
}

const ()

const KindKeyValuePair = ""

const (
	KeyValuePairFieldValue = "value"
	KeyValuePairFieldKey   = "key"
)

// MakeKeyValuePair makes KeyValuePair
func MakeKeyValuePair() *KeyValuePair {
	return &KeyValuePair{
		//TODO(nati): Apply default
		Value: "",
		Key:   "",
	}
}

// InterfaceToKeyValuePair converts interface to KeyValuePair
func InterfaceToKeyValuePair(i interface{}) *KeyValuePair {
	switch o := i.(type) {
	case *KeyValuePair:
		return o
	case KeyValuePair:
		return &o
	case map[string]interface{}:
		result := &KeyValuePair{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *KeyValuePair) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["value"]; ok {
		m.Value = format.InterfaceToString(val)

	}

	if val, ok := o["key"]; ok {
		m.Key = format.InterfaceToString(val)

	}

}

// ToMap makes map representation of a resource.
func (m *KeyValuePair) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"value": m.Value,

		"key": m.Key,
	}
}

// Kind returns kind of an resource.
func (m *KeyValuePair) Kind() string {
	return KindKeyValuePair
}

func (m *KeyValuePair) GetReferences() []basemodels.Reference {
	return nil
}

func (m *KeyValuePair) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *KeyValuePair) GetChildren() []basemodels.Object {
	return nil
}

func (m *KeyValuePair) AddBackReference(i interface{}) {}

func (m *KeyValuePair) AddChild(i interface{}) {
}

func (m *KeyValuePair) RemoveBackReference(i interface{}) {
}

func (m *KeyValuePair) RemoveChild(i interface{}) {
}

// MakeKeyValuePairSlice() makes a slice of KeyValuePair
func MakeKeyValuePairSlice() []*KeyValuePair {
	return []*KeyValuePair{}
}

// InterfaceToKeyValuePairSlice() makes a slice of KeyValuePair
func InterfaceToKeyValuePairSlice(i interface{}) []*KeyValuePair {
	if list, ok := i.([]*KeyValuePair); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*KeyValuePair{}
	for _, item := range list {
		result = append(result, InterfaceToKeyValuePair(item))
	}
	return result
}

const KindKeyValuePairs = ""

const (
	KeyValuePairsFieldKeyValuePair = "key_value_pair"
)

// MakeKeyValuePairs makes KeyValuePairs
func MakeKeyValuePairs() *KeyValuePairs {
	return &KeyValuePairs{
		//TODO(nati): Apply default

		KeyValuePair: MakeKeyValuePairSlice(),
	}
}

// InterfaceToKeyValuePairs converts interface to KeyValuePairs
func InterfaceToKeyValuePairs(i interface{}) *KeyValuePairs {
	switch o := i.(type) {
	case *KeyValuePairs:
		return o
	case KeyValuePairs:
		return &o
	case map[string]interface{}:
		result := &KeyValuePairs{}
		result.ApplyMap(o)
		return result

	case []interface{}:
		return &KeyValuePairs{

			KeyValuePair: InterfaceToKeyValuePairSlice(o),
		}

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *KeyValuePairs) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["key_value_pair"]; ok {

		m.KeyValuePair = InterfaceToKeyValuePairSlice(val)

	}

}

// ToMap makes map representation of a resource.
func (m *KeyValuePairs) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"key_value_pair": m.KeyValuePair,
	}
}

// Kind returns kind of an resource.
func (m *KeyValuePairs) Kind() string {
	return KindKeyValuePairs
}

func (m *KeyValuePairs) GetReferences() []basemodels.Reference {
	return nil
}

func (m *KeyValuePairs) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *KeyValuePairs) GetChildren() []basemodels.Object {
	return nil
}

func (m *KeyValuePairs) AddBackReference(i interface{}) {}

func (m *KeyValuePairs) AddChild(i interface{}) {
}

func (m *KeyValuePairs) RemoveBackReference(i interface{}) {
}

func (m *KeyValuePairs) RemoveChild(i interface{}) {
}

func (m *KeyValuePairs) SetInMap(value *KeyValuePair) error {

	if value.Key == "" {
		return errors.Errorf("field Key should not be empty")
	}

	for i, kv := range m.KeyValuePair {
		if kv.Key == value.Key {
			// key found - replace
			m.KeyValuePair[i] = value
			return nil
		}
	}
	// key not found - append
	m.KeyValuePair = append(m.KeyValuePair, value)
	return nil
}

func (m *KeyValuePairs) DeleteInMap(position string) {
	kvs := m.KeyValuePair
	for i, kv := range kvs {
		if fmt.Sprint(kv.Key) == position {
			// key found - delete
			m.KeyValuePair = append(kvs[:i], kvs[i+1:]...)
			return
		}
	}
}

// MakeKeyValuePairsSlice() makes a slice of KeyValuePairs
func MakeKeyValuePairsSlice() []*KeyValuePairs {
	return []*KeyValuePairs{}
}

// InterfaceToKeyValuePairsSlice() makes a slice of KeyValuePairs
func InterfaceToKeyValuePairsSlice(i interface{}) []*KeyValuePairs {
	if list, ok := i.([]*KeyValuePairs); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*KeyValuePairs{}
	for _, item := range list {
		result = append(result, InterfaceToKeyValuePairs(item))
	}
	return result
}

const KindAccessType = ""

const KindPermType = ""

const (
	PermTypeFieldOwner       = "owner"
	PermTypeFieldOwnerAccess = "owner_access"
	PermTypeFieldOtherAccess = "other_access"
	PermTypeFieldGroup       = "group"
	PermTypeFieldGroupAccess = "group_access"
)

// MakePermType makes PermType
func MakePermType() *PermType {
	return &PermType{
		//TODO(nati): Apply default
		Owner:       "",
		OwnerAccess: 0,
		OtherAccess: 0,
		Group:       "",
		GroupAccess: 0,
	}
}

// InterfaceToPermType converts interface to PermType
func InterfaceToPermType(i interface{}) *PermType {
	switch o := i.(type) {
	case *PermType:
		return o
	case PermType:
		return &o
	case map[string]interface{}:
		result := &PermType{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *PermType) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["owner"]; ok {
		m.Owner = format.InterfaceToString(val)

	}

	if val, ok := o["owner_access"]; ok {
		m.OwnerAccess = format.InterfaceToInt64(val)

	}

	if val, ok := o["other_access"]; ok {
		m.OtherAccess = format.InterfaceToInt64(val)

	}

	if val, ok := o["group"]; ok {
		m.Group = format.InterfaceToString(val)

	}

	if val, ok := o["group_access"]; ok {
		m.GroupAccess = format.InterfaceToInt64(val)

	}

}

// ToMap makes map representation of a resource.
func (m *PermType) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"owner": m.Owner,

		"owner_access": m.OwnerAccess,

		"other_access": m.OtherAccess,

		"group": m.Group,

		"group_access": m.GroupAccess,
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *PermType) UnmarshalJSON(b []byte) error {
	type alias PermType // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		OwnerAccess json.Number `json:""`
		OtherAccess json.Number `json:""`
		GroupAccess json.Number `json:""`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.OwnerAccess.String() != "" {
		m.OwnerAccess, err = obj.OwnerAccess.Int64()
		if err != nil {
			return err
		}
	}

	if obj.OtherAccess.String() != "" {
		m.OtherAccess, err = obj.OtherAccess.Int64()
		if err != nil {
			return err
		}
	}

	if obj.GroupAccess.String() != "" {
		m.GroupAccess, err = obj.GroupAccess.Int64()
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *PermType) Kind() string {
	return KindPermType
}

func (m *PermType) GetReferences() []basemodels.Reference {
	return nil
}

func (m *PermType) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *PermType) GetChildren() []basemodels.Object {
	return nil
}

func (m *PermType) AddBackReference(i interface{}) {}

func (m *PermType) AddChild(i interface{}) {
}

func (m *PermType) RemoveBackReference(i interface{}) {
}

func (m *PermType) RemoveChild(i interface{}) {
}

// MakePermTypeSlice() makes a slice of PermType
func MakePermTypeSlice() []*PermType {
	return []*PermType{}
}

// InterfaceToPermTypeSlice() makes a slice of PermType
func InterfaceToPermTypeSlice(i interface{}) []*PermType {
	if list, ok := i.([]*PermType); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*PermType{}
	for _, item := range list {
		result = append(result, InterfaceToPermType(item))
	}
	return result
}

const KindUuidType = ""

const (
	UuidTypeFieldUUIDMslong = "uuid_mslong"
	UuidTypeFieldUUIDLslong = "uuid_lslong"
)

// MakeUuidType makes UuidType
func MakeUuidType() *UuidType {
	return &UuidType{
		//TODO(nati): Apply default
		UUIDMslong: 0,
		UUIDLslong: 0,
	}
}

// InterfaceToUuidType converts interface to UuidType
func InterfaceToUuidType(i interface{}) *UuidType {
	switch o := i.(type) {
	case *UuidType:
		return o
	case UuidType:
		return &o
	case map[string]interface{}:
		result := &UuidType{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *UuidType) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["uuid_mslong"]; ok {
		m.UUIDMslong = format.InterfaceToUint64(val)

	}

	if val, ok := o["uuid_lslong"]; ok {
		m.UUIDLslong = format.InterfaceToUint64(val)

	}

}

// ToMap makes map representation of a resource.
func (m *UuidType) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"uuid_mslong": m.UUIDMslong,

		"uuid_lslong": m.UUIDLslong,
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *UuidType) UnmarshalJSON(b []byte) error {
	type alias UuidType // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		UUIDMslong json.Number `json:""`
		UUIDLslong json.Number `json:""`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.UUIDMslong.String() != "" {
		v, err := strconv.ParseUint(string(obj.UUIDMslong), 10, 64)
		m.UUIDMslong = uint64(v)
		if err != nil {
			return err
		}
	}

	if obj.UUIDLslong.String() != "" {
		v, err := strconv.ParseUint(string(obj.UUIDLslong), 10, 64)
		m.UUIDLslong = uint64(v)
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *UuidType) Kind() string {
	return KindUuidType
}

func (m *UuidType) GetReferences() []basemodels.Reference {
	return nil
}

func (m *UuidType) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *UuidType) GetChildren() []basemodels.Object {
	return nil
}

func (m *UuidType) AddBackReference(i interface{}) {}

func (m *UuidType) AddChild(i interface{}) {
}

func (m *UuidType) RemoveBackReference(i interface{}) {
}

func (m *UuidType) RemoveChild(i interface{}) {
}

// MakeUuidTypeSlice() makes a slice of UuidType
func MakeUuidTypeSlice() []*UuidType {
	return []*UuidType{}
}

// InterfaceToUuidTypeSlice() makes a slice of UuidType
func InterfaceToUuidTypeSlice(i interface{}) []*UuidType {
	if list, ok := i.([]*UuidType); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*UuidType{}
	for _, item := range list {
		result = append(result, InterfaceToUuidType(item))
	}
	return result
}

const KindIdPermsType = ""

const (
	IdPermsTypeFieldEnable       = "enable"
	IdPermsTypeFieldDescription  = "description"
	IdPermsTypeFieldCreated      = "created"
	IdPermsTypeFieldCreator      = "creator"
	IdPermsTypeFieldUserVisible  = "user_visible"
	IdPermsTypeFieldLastModified = "last_modified"
	IdPermsTypeFieldPermissions  = "permissions"
	IdPermsTypeFieldUUID         = "uuid"
)

// MakeIdPermsType makes IdPermsType
func MakeIdPermsType() *IdPermsType {
	return &IdPermsType{
		//TODO(nati): Apply default
		Enable:       false,
		Description:  "",
		Created:      "",
		Creator:      "",
		UserVisible:  false,
		LastModified: "",
		Permissions:  MakePermType(),
		UUID:         MakeUuidType(),
	}
}

// InterfaceToIdPermsType converts interface to IdPermsType
func InterfaceToIdPermsType(i interface{}) *IdPermsType {
	switch o := i.(type) {
	case *IdPermsType:
		return o
	case IdPermsType:
		return &o
	case map[string]interface{}:
		result := &IdPermsType{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *IdPermsType) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["enable"]; ok {
		m.Enable = format.InterfaceToBool(val)

	}

	if val, ok := o["description"]; ok {
		m.Description = format.InterfaceToString(val)

	}

	if val, ok := o["created"]; ok {
		m.Created = format.InterfaceToString(val)

	}

	if val, ok := o["creator"]; ok {
		m.Creator = format.InterfaceToString(val)

	}

	if val, ok := o["user_visible"]; ok {
		m.UserVisible = format.InterfaceToBool(val)

	}

	if val, ok := o["last_modified"]; ok {
		m.LastModified = format.InterfaceToString(val)

	}

	if val, ok := o["permissions"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.Permissions == nil {
			m.Permissions = &PermType{}
		}
		switch v := val.(type) {
		case toMapper:
			m.Permissions.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.Permissions.ApplyMap(v)
		case []interface{}:
			m.Permissions = InterfaceToPermType(v)
		}

	}

	if val, ok := o["uuid"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.UUID == nil {
			m.UUID = &UuidType{}
		}
		switch v := val.(type) {
		case toMapper:
			m.UUID.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.UUID.ApplyMap(v)
		case []interface{}:
			m.UUID = InterfaceToUuidType(v)
		}

	}

}

// ToMap makes map representation of a resource.
func (m *IdPermsType) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"enable": m.Enable,

		"description": m.Description,

		"created": m.Created,

		"creator": m.Creator,

		"user_visible": m.UserVisible,

		"last_modified": m.LastModified,

		"permissions": m.Permissions.ToMap(),

		"uuid": m.UUID.ToMap(),
	}
}

// Kind returns kind of an resource.
func (m *IdPermsType) Kind() string {
	return KindIdPermsType
}

func (m *IdPermsType) GetReferences() []basemodels.Reference {
	return nil
}

func (m *IdPermsType) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *IdPermsType) GetChildren() []basemodels.Object {
	return nil
}

func (m *IdPermsType) AddBackReference(i interface{}) {}

func (m *IdPermsType) AddChild(i interface{}) {
}

func (m *IdPermsType) RemoveBackReference(i interface{}) {
}

func (m *IdPermsType) RemoveChild(i interface{}) {
}

// MakeIdPermsTypeSlice() makes a slice of IdPermsType
func MakeIdPermsTypeSlice() []*IdPermsType {
	return []*IdPermsType{}
}

// InterfaceToIdPermsTypeSlice() makes a slice of IdPermsType
func InterfaceToIdPermsTypeSlice(i interface{}) []*IdPermsType {
	if list, ok := i.([]*IdPermsType); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*IdPermsType{}
	for _, item := range list {
		result = append(result, InterfaceToIdPermsType(item))
	}
	return result
}

const KindShareType = ""

const (
	ShareTypeFieldTenantAccess = "tenant_access"
	ShareTypeFieldTenant       = "tenant"
)

// MakeShareType makes ShareType
func MakeShareType() *ShareType {
	return &ShareType{
		//TODO(nati): Apply default
		TenantAccess: 0,
		Tenant:       "",
	}
}

// InterfaceToShareType converts interface to ShareType
func InterfaceToShareType(i interface{}) *ShareType {
	switch o := i.(type) {
	case *ShareType:
		return o
	case ShareType:
		return &o
	case map[string]interface{}:
		result := &ShareType{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *ShareType) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["tenant_access"]; ok {
		m.TenantAccess = format.InterfaceToInt64(val)

	}

	if val, ok := o["tenant"]; ok {
		m.Tenant = format.InterfaceToString(val)

	}

}

// ToMap makes map representation of a resource.
func (m *ShareType) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"tenant_access": m.TenantAccess,

		"tenant": m.Tenant,
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *ShareType) UnmarshalJSON(b []byte) error {
	type alias ShareType // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		TenantAccess json.Number `json:""`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.TenantAccess.String() != "" {
		m.TenantAccess, err = obj.TenantAccess.Int64()
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *ShareType) Kind() string {
	return KindShareType
}

func (m *ShareType) GetReferences() []basemodels.Reference {
	return nil
}

func (m *ShareType) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *ShareType) GetChildren() []basemodels.Object {
	return nil
}

func (m *ShareType) AddBackReference(i interface{}) {}

func (m *ShareType) AddChild(i interface{}) {
}

func (m *ShareType) RemoveBackReference(i interface{}) {
}

func (m *ShareType) RemoveChild(i interface{}) {
}

// MakeShareTypeSlice() makes a slice of ShareType
func MakeShareTypeSlice() []*ShareType {
	return []*ShareType{}
}

// InterfaceToShareTypeSlice() makes a slice of ShareType
func InterfaceToShareTypeSlice(i interface{}) []*ShareType {
	if list, ok := i.([]*ShareType); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*ShareType{}
	for _, item := range list {
		result = append(result, InterfaceToShareType(item))
	}
	return result
}

const KindPermType2 = ""

const (
	PermType2FieldOwner        = "owner"
	PermType2FieldOwnerAccess  = "owner_access"
	PermType2FieldGlobalAccess = "global_access"
	PermType2FieldShare        = "share"
)

// MakePermType2 makes PermType2
func MakePermType2() *PermType2 {
	return &PermType2{
		//TODO(nati): Apply default
		Owner:        "",
		OwnerAccess:  0,
		GlobalAccess: 0,

		Share: MakeShareTypeSlice(),
	}
}

// InterfaceToPermType2 converts interface to PermType2
func InterfaceToPermType2(i interface{}) *PermType2 {
	switch o := i.(type) {
	case *PermType2:
		return o
	case PermType2:
		return &o
	case map[string]interface{}:
		result := &PermType2{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *PermType2) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["owner"]; ok {
		m.Owner = format.InterfaceToString(val)

	}

	if val, ok := o["owner_access"]; ok {
		m.OwnerAccess = format.InterfaceToInt64(val)

	}

	if val, ok := o["global_access"]; ok {
		m.GlobalAccess = format.InterfaceToInt64(val)

	}

	if val, ok := o["share"]; ok {

		m.Share = InterfaceToShareTypeSlice(val)

	}

}

// ToMap makes map representation of a resource.
func (m *PermType2) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"owner": m.Owner,

		"owner_access": m.OwnerAccess,

		"global_access": m.GlobalAccess,

		"share": m.Share,
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *PermType2) UnmarshalJSON(b []byte) error {
	type alias PermType2 // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		OwnerAccess  json.Number `json:""`
		GlobalAccess json.Number `json:""`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.OwnerAccess.String() != "" {
		m.OwnerAccess, err = obj.OwnerAccess.Int64()
		if err != nil {
			return err
		}
	}

	if obj.GlobalAccess.String() != "" {
		m.GlobalAccess, err = obj.GlobalAccess.Int64()
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *PermType2) Kind() string {
	return KindPermType2
}

func (m *PermType2) GetReferences() []basemodels.Reference {
	return nil
}

func (m *PermType2) GetBackReferences() []basemodels.Object {
	return nil
}

func (m *PermType2) GetChildren() []basemodels.Object {
	return nil
}

func (m *PermType2) AddBackReference(i interface{}) {}

func (m *PermType2) AddChild(i interface{}) {
}

func (m *PermType2) RemoveBackReference(i interface{}) {
}

func (m *PermType2) RemoveChild(i interface{}) {
}

// MakePermType2Slice() makes a slice of PermType2
func MakePermType2Slice() []*PermType2 {
	return []*PermType2{}
}

// InterfaceToPermType2Slice() makes a slice of PermType2
func InterfaceToPermType2Slice(i interface{}) []*PermType2 {
	if list, ok := i.([]*PermType2); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*PermType2{}
	for _, item := range list {
		result = append(result, InterfaceToPermType2(item))
	}
	return result
}

const KindSample = "sample"

const (
	SampleFieldUUID                 = "uuid"
	SampleFieldName                 = "name"
	SampleFieldParentUUID           = "parent_uuid"
	SampleFieldParentType           = "parent_type"
	SampleFieldFQName               = "fq_name"
	SampleFieldIDPerms              = "id_perms"
	SampleFieldDisplayName          = "display_name"
	SampleFieldAnnotations          = "annotations"
	SampleFieldPerms2               = "perms2"
	SampleFieldConfigurationVersion = "configuration_version"
	SampleFieldContainerConfig      = "container_config"
	SampleFieldContentConfig        = "content_config"
	SampleFieldLayoutConfig         = "layout_config"

	SampleFieldTagRefs = "tag_refs"
)

// MakeSample makes Sample
func MakeSample() *Sample {
	return &Sample{
		//TODO(nati): Apply default
		UUID:                 "",
		Name:                 "",
		ParentUUID:           "",
		ParentType:           "",
		FQName:               []string{},
		IDPerms:              MakeIdPermsType(),
		DisplayName:          "",
		Annotations:          MakeKeyValuePairs(),
		Perms2:               MakePermType2(),
		ConfigurationVersion: 0,
		ContainerConfig:      "",
		ContentConfig:        "",
		LayoutConfig:         "",
	}
}

// InterfaceToSample converts interface to Sample
func InterfaceToSample(i interface{}) *Sample {
	switch o := i.(type) {
	case *Sample:
		return o
	case Sample:
		return &o
	case map[string]interface{}:
		result := &Sample{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *Sample) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["uuid"]; ok {
		m.UUID = format.InterfaceToString(val)

	}

	if val, ok := o["name"]; ok {
		m.Name = format.InterfaceToString(val)

	}

	if val, ok := o["parent_uuid"]; ok {
		m.ParentUUID = format.InterfaceToString(val)

	}

	if val, ok := o["parent_type"]; ok {
		m.ParentType = format.InterfaceToString(val)

	}

	if val, ok := o["fq_name"]; ok {
		m.FQName = format.InterfaceToStringList(val)

	}

	if val, ok := o["id_perms"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.IDPerms == nil {
			m.IDPerms = &IdPermsType{}
		}
		switch v := val.(type) {
		case toMapper:
			m.IDPerms.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.IDPerms.ApplyMap(v)
		case []interface{}:
			m.IDPerms = InterfaceToIdPermsType(v)
		}

	}

	if val, ok := o["display_name"]; ok {
		m.DisplayName = format.InterfaceToString(val)

	}

	if val, ok := o["annotations"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.Annotations == nil {
			m.Annotations = &KeyValuePairs{}
		}
		switch v := val.(type) {
		case toMapper:
			m.Annotations.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.Annotations.ApplyMap(v)
		case []interface{}:
			m.Annotations = InterfaceToKeyValuePairs(v)
		}

	}

	if val, ok := o["perms2"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.Perms2 == nil {
			m.Perms2 = &PermType2{}
		}
		switch v := val.(type) {
		case toMapper:
			m.Perms2.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.Perms2.ApplyMap(v)
		case []interface{}:
			m.Perms2 = InterfaceToPermType2(v)
		}

	}

	if val, ok := o["configuration_version"]; ok {
		m.ConfigurationVersion = format.InterfaceToInt64(val)

	}

	if val, ok := o["container_config"]; ok {
		m.ContainerConfig = format.InterfaceToString(val)

	}

	if val, ok := o["content_config"]; ok {
		m.ContentConfig = format.InterfaceToString(val)

	}

	if val, ok := o["layout_config"]; ok {
		m.LayoutConfig = format.InterfaceToString(val)

	}

	if val, ok := o["tag_refs"]; ok {
		m.TagRefs = InterfaceToSampleTagRefs(val)
	}
}

// ToMap makes map representation of a resource.
func (m *Sample) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"uuid": m.UUID,

		"name": m.Name,

		"parent_uuid": m.ParentUUID,

		"parent_type": m.ParentType,

		"fq_name": m.FQName,

		"id_perms": m.IDPerms.ToMap(),

		"display_name": m.DisplayName,

		"annotations": m.Annotations.ToMap(),

		"perms2": m.Perms2.ToMap(),

		"configuration_version": m.ConfigurationVersion,

		"container_config": m.ContainerConfig,

		"content_config": m.ContentConfig,

		"layout_config": m.LayoutConfig,

		"tag_refs": SampleTagRefsToMap(m.TagRefs),
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *Sample) UnmarshalJSON(b []byte) error {
	type alias Sample // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		ConfigurationVersion json.Number `json:"sample"`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.ConfigurationVersion.String() != "" {
		m.ConfigurationVersion, err = obj.ConfigurationVersion.Int64()
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *Sample) Kind() string {
	return KindSample
}

func (m *Sample) GetReferences() []basemodels.Reference {
	if m == nil {
		return nil
	}
	var refs []basemodels.Reference

	for _, ref := range m.TagRefs {
		refs = append(refs, ref)
	}

	return refs
}

func (m *Sample) GetBackReferences() []basemodels.Object {
	if m == nil {
		return nil
	}
	var backRefs []basemodels.Object
	return backRefs
}

func (m *Sample) GetChildren() []basemodels.Object {
	if m == nil {
		return nil
	}
	var children []basemodels.Object

	return children
}

func (m *Sample) AddBackReference(i interface{}) {}

func (m *Sample) AddChild(i interface{}) {
}

func (m *Sample) RemoveBackReference(i interface{}) {
}

func (m *Sample) RemoveChild(i interface{}) {
}

func (m *Sample) ApplyPropCollectionUpdate(u *basemodels.PropCollectionUpdate) (map[string]interface{}, error) {
	switch u.Field {

	case SampleFieldAnnotations:
		err := u.ValidateForMap()
		if err != nil {
			return nil, err
		}
		switch strings.ToLower(u.Operation) {
		case basemodels.PropCollectionUpdateOperationSet:
			var value KeyValuePair
			if err := json.Unmarshal(u.Value, &value); err != nil {
				return nil, errors.Wrap(err, "malformed value field")
			}
			if err := m.Annotations.SetInMap(&value); err != nil {
				return nil, err
			}
		case basemodels.PropCollectionUpdateOperationDelete:
			m.Annotations.DeleteInMap(u.Position)
		}
		return map[string]interface{}{u.Field: m.Annotations}, nil

	default:
		return nil, errors.Errorf("type sample has no prop collection field named: %s", u.Field)
	}
}

func SampleTagRefsToMap(l []*SampleTagRef) []interface{} {
	var result []interface{}
	for _, i := range l {
		result = append(result, i.ToMap())
	}
	return result
}

func (r *SampleTagRef) SetUUID(uuid string) {
	r.UUID = uuid
}

func (r *SampleTagRef) SetTo(to []string) {
	r.To = to
}

func (r *SampleTagRef) GetReferredKind() string {
	return KindTag
}

func (r *SampleTagRef) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"uuid": r.UUID,
		"to":   r.To,
	}
}

func InterfaceToSampleTagRefs(i interface{}) []*SampleTagRef {
	list, ok := i.([]interface{})
	if !ok {
		return nil
	}
	result := []*SampleTagRef{}
	for _, item := range list {
		m, ok := item.(map[string]interface{})
		_ = m
		if !ok {
			return nil
		}
		result = append(result, &SampleTagRef{
			UUID: format.InterfaceToString(m["uuid"]),
			To:   format.InterfaceToStringList(m["to"]),
		})
	}

	return result
}

func (m *Sample) AddTagRef(to *SampleTagRef) {

	if to == nil {
		return
	}

	result := m.TagRefs
	updated := false
	for i, e := range result {
		if e.UUID == to.GetUUID() {
			result[i] = to
			updated = true
		}
	}
	if !updated {
		result = append(result, to)
	}

	m.TagRefs = result

}

func (m *Sample) RemoveTagRef(to *SampleTagRef) {

	if to == nil {
		return
	}

	result := m.TagRefs[:0]
	for _, e := range m.TagRefs {
		if e.UUID != to.GetUUID() {
			result = append(result, e)
		}
	}

	m.TagRefs = result

}

// MakeSampleSlice() makes a slice of Sample
func MakeSampleSlice() []*Sample {
	return []*Sample{}
}

// InterfaceToSampleSlice() makes a slice of Sample
func InterfaceToSampleSlice(i interface{}) []*Sample {
	if list, ok := i.([]*Sample); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*Sample{}
	for _, item := range list {
		result = append(result, InterfaceToSample(item))
	}
	return result
}

const KindTag = "tag"

const (
	TagFieldUUID                 = "uuid"
	TagFieldName                 = "name"
	TagFieldParentUUID           = "parent_uuid"
	TagFieldParentType           = "parent_type"
	TagFieldFQName               = "fq_name"
	TagFieldIDPerms              = "id_perms"
	TagFieldDisplayName          = "display_name"
	TagFieldAnnotations          = "annotations"
	TagFieldPerms2               = "perms2"
	TagFieldConfigurationVersion = "configuration_version"
	TagFieldTagValue             = "tag_value"

	TagFieldTagRefs = "tag_refs"
)

// MakeTag makes Tag
func MakeTag() *Tag {
	return &Tag{
		//TODO(nati): Apply default
		UUID:                 "",
		Name:                 "",
		ParentUUID:           "",
		ParentType:           "",
		FQName:               []string{},
		IDPerms:              MakeIdPermsType(),
		DisplayName:          "",
		Annotations:          MakeKeyValuePairs(),
		Perms2:               MakePermType2(),
		ConfigurationVersion: 0,
		TagValue:             "",
	}
}

// InterfaceToTag converts interface to Tag
func InterfaceToTag(i interface{}) *Tag {
	switch o := i.(type) {
	case *Tag:
		return o
	case Tag:
		return &o
	case map[string]interface{}:
		result := &Tag{}
		result.ApplyMap(o)
		return result

	default:
		return nil
	}
}

// ApplyMap updates object with values from map.
func (m *Tag) ApplyMap(o map[string]interface{}) {
	if len(o) == 0 || m == nil {
		return
	}

	if val, ok := o["uuid"]; ok {
		m.UUID = format.InterfaceToString(val)

	}

	if val, ok := o["name"]; ok {
		m.Name = format.InterfaceToString(val)

	}

	if val, ok := o["parent_uuid"]; ok {
		m.ParentUUID = format.InterfaceToString(val)

	}

	if val, ok := o["parent_type"]; ok {
		m.ParentType = format.InterfaceToString(val)

	}

	if val, ok := o["fq_name"]; ok {
		m.FQName = format.InterfaceToStringList(val)

	}

	if val, ok := o["id_perms"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.IDPerms == nil {
			m.IDPerms = &IdPermsType{}
		}
		switch v := val.(type) {
		case toMapper:
			m.IDPerms.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.IDPerms.ApplyMap(v)
		case []interface{}:
			m.IDPerms = InterfaceToIdPermsType(v)
		}

	}

	if val, ok := o["display_name"]; ok {
		m.DisplayName = format.InterfaceToString(val)

	}

	if val, ok := o["annotations"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.Annotations == nil {
			m.Annotations = &KeyValuePairs{}
		}
		switch v := val.(type) {
		case toMapper:
			m.Annotations.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.Annotations.ApplyMap(v)
		case []interface{}:
			m.Annotations = InterfaceToKeyValuePairs(v)
		}

	}

	if val, ok := o["perms2"]; ok {
		type toMapper interface{ ToMap() map[string]interface{} }
		if m.Perms2 == nil {
			m.Perms2 = &PermType2{}
		}
		switch v := val.(type) {
		case toMapper:
			m.Perms2.ApplyMap(v.ToMap())
		case map[string]interface{}:
			m.Perms2.ApplyMap(v)
		case []interface{}:
			m.Perms2 = InterfaceToPermType2(v)
		}

	}

	if val, ok := o["configuration_version"]; ok {
		m.ConfigurationVersion = format.InterfaceToInt64(val)

	}

	if val, ok := o["tag_value"]; ok {
		m.TagValue = format.InterfaceToString(val)

	}

	if val, ok := o["tag_refs"]; ok {
		m.TagRefs = InterfaceToTagTagRefs(val)
	}
}

// ToMap makes map representation of a resource.
func (m *Tag) ToMap() map[string]interface{} {
	if m == nil {
		return nil
	}
	return map[string]interface{}{

		"uuid": m.UUID,

		"name": m.Name,

		"parent_uuid": m.ParentUUID,

		"parent_type": m.ParentType,

		"fq_name": m.FQName,

		"id_perms": m.IDPerms.ToMap(),

		"display_name": m.DisplayName,

		"annotations": m.Annotations.ToMap(),

		"perms2": m.Perms2.ToMap(),

		"configuration_version": m.ConfigurationVersion,

		"tag_value": m.TagValue,

		"tag_refs": TagTagRefsToMap(m.TagRefs),
	}
}

// UnmarshalJSON is implementation of custom unmarshalling logic that properly
// unmarshals numbers provided as JSON strings.
func (m *Tag) UnmarshalJSON(b []byte) error {
	type alias Tag // alias is created to avoid infinite recursion
	obj := struct {
		*alias
		ConfigurationVersion json.Number `json:"tag"`
	}{alias: (*alias)(m)}
	err := json.Unmarshal(b, &obj)
	if err != nil {
		return err
	}

	if obj.ConfigurationVersion.String() != "" {
		m.ConfigurationVersion, err = obj.ConfigurationVersion.Int64()
		if err != nil {
			return err
		}
	}

	return err
}

// Kind returns kind of an resource.
func (m *Tag) Kind() string {
	return KindTag
}

func (m *Tag) GetReferences() []basemodels.Reference {
	if m == nil {
		return nil
	}
	var refs []basemodels.Reference

	for _, ref := range m.TagRefs {
		refs = append(refs, ref)
	}

	return refs
}

func (m *Tag) GetBackReferences() []basemodels.Object {
	if m == nil {
		return nil
	}
	var backRefs []basemodels.Object
	for _, backRef := range m.TagBackRefs {
		backRefs = append(backRefs, backRef)
	}

	for _, backRef := range m.SampleBackRefs {
		backRefs = append(backRefs, backRef)
	}

	return backRefs
}

func (m *Tag) GetChildren() []basemodels.Object {
	if m == nil {
		return nil
	}
	var children []basemodels.Object

	return children
}

func (m *Tag) AddBackReference(i interface{}) {
	switch resource := i.(type) {
	case *Sample:
		m.AddSampleBackref(resource)
	case *Tag:
		m.AddTagBackref(resource)
	}
}

func (m *Tag) AddChild(i interface{}) {
}

func (m *Tag) RemoveBackReference(i interface{}) {
	switch resource := i.(type) {
	case *Sample:
		m.RemoveSampleBackref(resource)
	case *Tag:
		m.RemoveTagBackref(resource)
	}
}

func (m *Tag) RemoveChild(i interface{}) {
}

func (m *Tag) ApplyPropCollectionUpdate(u *basemodels.PropCollectionUpdate) (map[string]interface{}, error) {
	switch u.Field {

	case TagFieldAnnotations:
		err := u.ValidateForMap()
		if err != nil {
			return nil, err
		}
		switch strings.ToLower(u.Operation) {
		case basemodels.PropCollectionUpdateOperationSet:
			var value KeyValuePair
			if err := json.Unmarshal(u.Value, &value); err != nil {
				return nil, errors.Wrap(err, "malformed value field")
			}
			if err := m.Annotations.SetInMap(&value); err != nil {
				return nil, err
			}
		case basemodels.PropCollectionUpdateOperationDelete:
			m.Annotations.DeleteInMap(u.Position)
		}
		return map[string]interface{}{u.Field: m.Annotations}, nil

	default:
		return nil, errors.Errorf("type tag has no prop collection field named: %s", u.Field)
	}
}

func TagTagRefsToMap(l []*TagTagRef) []interface{} {
	var result []interface{}
	for _, i := range l {
		result = append(result, i.ToMap())
	}
	return result
}

func (r *TagTagRef) SetUUID(uuid string) {
	r.UUID = uuid
}

func (r *TagTagRef) SetTo(to []string) {
	r.To = to
}

func (r *TagTagRef) GetReferredKind() string {
	return KindTag
}

func (r *TagTagRef) ToMap() map[string]interface{} {
	return map[string]interface{}{
		"uuid": r.UUID,
		"to":   r.To,
	}
}

func InterfaceToTagTagRefs(i interface{}) []*TagTagRef {
	list, ok := i.([]interface{})
	if !ok {
		return nil
	}
	result := []*TagTagRef{}
	for _, item := range list {
		m, ok := item.(map[string]interface{})
		_ = m
		if !ok {
			return nil
		}
		result = append(result, &TagTagRef{
			UUID: format.InterfaceToString(m["uuid"]),
			To:   format.InterfaceToStringList(m["to"]),
		})
	}

	return result
}

func (m *Tag) AddTagRef(to *TagTagRef) {

	if to == nil {
		return
	}

	result := m.TagRefs
	updated := false
	for i, e := range result {
		if e.UUID == to.GetUUID() {
			result[i] = to
			updated = true
		}
	}
	if !updated {
		result = append(result, to)
	}

	m.TagRefs = result

}

func (m *Tag) RemoveTagRef(to *TagTagRef) {

	if to == nil {
		return
	}

	result := m.TagRefs[:0]
	for _, e := range m.TagRefs {
		if e.UUID != to.GetUUID() {
			result = append(result, e)
		}
	}

	m.TagRefs = result

}

func (m *Tag) AddSampleBackref(to *Sample) {

	if to == nil {
		return
	}

	result := m.SampleBackRefs
	updated := false
	for i, e := range result {
		if e.UUID == to.GetUUID() {
			result[i] = to
			updated = true
		}
	}
	if !updated {
		result = append(result, to)
	}

	m.SampleBackRefs = result

}

func (m *Tag) RemoveSampleBackref(to *Sample) {

	if to == nil {
		return
	}

	result := m.SampleBackRefs[:0]
	for _, e := range m.SampleBackRefs {
		if e.UUID != to.GetUUID() {
			result = append(result, e)
		}
	}

	m.SampleBackRefs = result

}

func (m *Tag) AddTagBackref(to *Tag) {

	if to == nil {
		return
	}

	result := m.TagBackRefs
	updated := false
	for i, e := range result {
		if e.UUID == to.GetUUID() {
			result[i] = to
			updated = true
		}
	}
	if !updated {
		result = append(result, to)
	}

	m.TagBackRefs = result

}

func (m *Tag) RemoveTagBackref(to *Tag) {

	if to == nil {
		return
	}

	result := m.TagBackRefs[:0]
	for _, e := range m.TagBackRefs {
		if e.UUID != to.GetUUID() {
			result = append(result, e)
		}
	}

	m.TagBackRefs = result

}

// MakeTagSlice() makes a slice of Tag
func MakeTagSlice() []*Tag {
	return []*Tag{}
}

// InterfaceToTagSlice() makes a slice of Tag
func InterfaceToTagSlice(i interface{}) []*Tag {
	if list, ok := i.([]*Tag); ok {
		return list
	}
	list := format.InterfaceToInterfaceList(i)
	if list == nil {
		return nil
	}
	result := []*Tag{}
	for _, item := range list {
		result = append(result, InterfaceToTag(item))
	}
	return result
}
